{"title":{"en":"B. Reverse Sort","ru":"B. Реверс сорт"},"contestId":"1605","problemIndex":"B","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"256 megabytes","ru":"256 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p>Ashish has a binary string $$$s$$$ of length $$$n$$$ that he wants to sort in non-decreasing order.</p><p>He can perform the following operation: </p><ol> <li> Choose a subsequence of any length such that its elements are in non-increasing order. Formally, choose any $$$k$$$ such that $$$1 \\leq k \\leq n$$$ and any sequence of $$$k$$$ indices $$$1 \\le i_1 \\lt i_2 \\lt \\ldots \\lt i_k \\le n$$$ such that $$$s_{i_1} \\ge s_{i_2} \\ge \\ldots \\ge s_{i_k}$$$. </li><li> Reverse this subsequence in-place. Formally, swap $$$s_{i_1}$$$ with $$$s_{i_k}$$$, swap $$$s_{i_2}$$$ with $$$s_{i_{k-1}}$$$, $$$\\ldots$$$ and swap $$$s_{i_{\\lfloor k/2 \\rfloor}}$$$ with $$$s_{i_{\\lceil k/2 \\rceil + 1}}$$$ (Here $$$\\lfloor x \\rfloor$$$ denotes the largest integer not exceeding $$$x$$$, and $$$\\lceil x \\rceil$$$ denotes the smallest integer not less than $$$x$$$) </li></ol><p>Find the minimum number of operations required to sort the string in non-decreasing order. It can be proven that it is always possible to sort the given binary string in at most $$$n$$$ operations.</p>","ru":"<p>У Ashish есть бинарная строка $$$s$$$ длины $$$n$$$, которую он хочет отсортировать в неубывающем порядке.</p><p>Он может выполнять следующую операцию: </p><ol> <li> Выберите подпоследовательность любой длины, элементы которой идут в невозрастающем порядке. Формально, выберите любое $$$k$$$ такое, что $$$1 \\leq k \\leq n$$$ и любую последовательность $$$k$$$ индексов $$$1 \\le i_1 \\lt i_2 \\lt \\ldots \\lt i_k \\le n$$$ такую, что $$$s_{i_1} \\ge s_{i_2} \\ge \\ldots \\ge s_{i_k}$$$. </li><li> Затем, «разверните» эту последовательность. Формально, поменяйте местами $$$s_{i_1}$$$ с $$$s_{i_k}$$$, $$$s_{i_2}$$$ с $$$s_{i_{k-1}}$$$, $$$\\ldots$$$ и $$$s_{i_{\\lfloor k/2 \\rfloor}}$$$ с $$$s_{i_{\\lceil k/2 \\rceil + 1}}$$$ (Здесь $$$\\lfloor x \\rfloor$$$ обозначает наибольшее целое число, не превосходящее $$$x$$$, а $$$\\lceil x \\rceil$$$ обозначает наименьшее целое число, не меньшее $$$x$$$). </li></ol><p>Найдите минимальное количество операций, необходимых для того, чтобы отсортировать строку в неубывающем порядке. Можно доказать, что всегда можно отсортировать заданную бинарную строку не более чем за $$$n$$$ операций.</p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The first line contains a single integer $$$t$$$ $$$(1 \\le t \\le 1000)$$$ &nbsp;— the number of test cases. The description of the test cases follows.</p><p>The first line of each test case contains an integer $$$n$$$ $$$(1 \\le n \\le 1000)$$$ &nbsp;— the length of the binary string $$$s$$$.</p><p>The second line of each test case contains a binary string $$$s$$$ of length $$$n$$$ containing only $$$0$$$s and $$$1$$$s.</p><p>It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$1000$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>Первая строка содержит одно целое число $$$t$$$ $$$(1 \\le t \\le 1000)$$$ &nbsp;— количество наборов входных данных. Далее следует описание наборов входных данных.</p><p>Первая строка каждого набора входных данных содержит целое число $$$n$$$ $$$(1 \\le n \\le 1000)$$$ &nbsp;— длину бинарной строки $$$s$$$.</p><p>Вторая строка каждого набора входных данных содержит бинарную строку $$$s$$$ длины $$$n$$$, содержащую только символы $$$0$$$ и $$$1$$$.</p><p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных не превышает $$$1000$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>For each test case output the following:</p><ul> <li> The <span class=\"tex-font-style-bf\">minimum</span> number of operations $$$m$$$ in the first line ($$$0 \\le m \\le n$$$). </li><li> Each of the following $$$m$$$ lines should be of the form: $$$k$$$ $$$i_1$$$ $$$i_2$$$ ... $$$i_{k}$$$, where $$$k$$$ is the length and $$$i_1 \\lt i_2 \\lt ... \\lt i_{k}$$$ are the indices of the chosen subsequence. For them the conditions from the statement must hold. </li></ul>","ru":"<div class=\"section-title\">Выходные данные</div><p>Для каждого набора входных данных выведите следующее:</p><ul> <li> <span class=\"tex-font-style-bf\">минимальное</span> количество операций $$$m$$$ в первой строке ($$$0 \\le m \\le n$$$). </li><li> Каждая из следующих $$$m$$$ строк должна иметь вид: $$$k$$$ $$$i_1$$$ $$$i_2$$$ ... $$$i_{k}$$$, где $$$k$$$ — длина, а $$$i_1 \\lt i_2 \\lt ... \\lt i_{k}$$$ — индексы выбранной подпоследовательности. Для них должны выполняться ограничения из условия. </li></ul>"},"noteHtml":{"en":"<div class=\"section-title\">Note</div><p>In the first test case, the binary string is already sorted in non-decreasing order.</p><p>In the second test case, we can perform the following operation: </p><ul> <li> $$$k = 4:$$$ choose the indices $$$\\{1, 3, 4, 5\\}$$$<p>$$$\\underline{1}$$$ $$$0$$$ $$$\\underline{1}$$$ $$$\\underline{0}$$$ $$$\\underline{0}$$$ $$$\\rightarrow $$$ $$$\\underline{0}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{1}$$$ $$$\\underline{1}$$$ </p></li></ul><p>In the third test case, we can perform the following operation:</p><ul> <li> $$$k = 3:$$$ choose the indices $$$\\{3, 5, 6\\}$$$<p>$$$0$$$ $$$0$$$ $$$\\underline{1}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{0}$$$ $$$\\rightarrow $$$ $$$0$$$ $$$0$$$ $$$\\underline{0}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{1}$$$</p></li></ul>","ru":"<div class=\"section-title\">Примечание</div><p>В первом наборе входных данных строка уже отсортирована в неубывающем порядке.</p><p>Во втором наборе входных данных мы можем выполнить следующую операцию: </p><ul> <li> $$$k = 4:$$$ выбираем индексы $$$\\{1, 3, 4, 5\\}$$$<p>$$$\\underline{1}$$$ $$$0$$$ $$$\\underline{1}$$$ $$$\\underline{0}$$$ $$$\\underline{0}$$$ $$$\\rightarrow $$$ $$$\\underline{0}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{1}$$$ $$$\\underline{1}$$$ </p></li></ul><p>В третьем наборе входных данных мы можем выполнить следующую операцию:</p><ul> <li> $$$k = 3:$$$ выбираем индексы $$$\\{3, 5, 6\\}$$$<p>$$$0$$$ $$$0$$$ $$$\\underline{1}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{0}$$$ $$$\\rightarrow $$$ $$$0$$$ $$$0$$$ $$$\\underline{0}$$$ $$$0$$$ $$$\\underline{0}$$$ $$$\\underline{1}$$$</p></li></ul>"},"sampleTestcases":[{"id":1636727724782,"input":"3\n7\n0011111\n5\n10100\n6\n001000","output":"0\n1\n4 1 3 4 5 \n1\n3 3 5 6 \n","result":{"id":1636727724782,"stdout":"0\n1\n4 1 3 4 5\n1\n2 3 6\n","stderr":"","exitcode":0,"signal":null,"time":2,"timeout":false}}],"submitUrl":"https://codeforces.com/contest/1605/submit","language":"c++","isPartOfContest":true,"langId":"54"}