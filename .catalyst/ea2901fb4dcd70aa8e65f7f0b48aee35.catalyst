{"title":{"en":"D. Treelabeling","ru":"D. Деревонумерация"},"contestId":"1605","problemIndex":"D","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"256 megabytes","ru":"256 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p>Eikooc and Sushi play a game.</p><p>The game is played on a tree having $$$n$$$ nodes numbered $$$1$$$ to $$$n$$$. Recall that a tree having $$$n$$$ nodes is an undirected, connected graph with $$$n-1$$$ edges.</p><p>They take turns alternately moving a token on the tree. <span class=\"tex-font-style-bf\">Eikooc makes the first move, placing the token</span> on any node of her choice. Sushi makes the next move, followed by Eikooc, followed by Sushi, and so on. In each turn after the first, a player must move the token to a node $$$u$$$ such that </p><ul> <li> $$$u$$$ is adjacent to the node $$$v$$$ the token is currently on </li><li> $$$u$$$ has not been visited before </li><li> $$$u \\oplus v \\leq min(u, v)$$$ </li></ul><p>Here $$$x \\oplus y$$$ denotes the <a href=\"https://en.wikipedia.org/wiki/Bitwise_operation#XOR\">bitwise XOR</a> operation on integers $$$x$$$ and $$$y$$$.</p><p>Both the players play optimally. The player who is unable to make a move loses.</p><p>The following are examples which demonstrate the rules of the game. </p><center> <table class=\"tex-tabular\"><tbody><tr><td class=\"tex-tabular-text-align-left\"><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/3295a7d6e7a175749cce0ef394201d059dcccbfd.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"> </center> <span class=\"tex-font-style-it\">Suppose Eikooc starts the game by placing the token at node $$$4$$$. Sushi then moves the token to node $$$6$$$, which is unvisited and adjacent to $$$4$$$. It also holds that $$$6 \\oplus 4 = 2 \\leq min(6, 4)$$$. In the next turn, Eikooc moves the token to node $$$5$$$, which is unvisited and adjacent to $$$6$$$. It holds that $$$5 \\oplus 6 = 3 \\leq min(5, 6)$$$. Sushi has no more moves to play, so she loses.</span></td><td class=\"tex-tabular-text-align-left\"><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/a67b0033a1f799229927f151e8e6cda92aa46b14.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"> </center> <span class=\"tex-font-style-it\">Suppose Eikooc starts the game by placing the token at node $$$3$$$. Sushi moves the token to node $$$2$$$, which is unvisited and adjacent to $$$3$$$. It also holds that $$$3 \\oplus 2 = 1 \\leq min(3, 2)$$$. Eikooc cannot move the token to node $$$6$$$ since $$$6 \\oplus 2 = 4 \\nleq min(6, 2)$$$. Since Eikooc has no moves to play, she loses.</span></td></tr></tbody></table> </center><p>Before the game begins, Eikooc decides to sneakily relabel the nodes of the tree in her favour. Formally, a relabeling is a permutation $$$p$$$ of length $$$n$$$ (sequence of $$$n$$$ integers wherein each integer from $$$1$$$ to $$$n$$$ occurs exactly once) where $$$p_i$$$ denotes the new numbering of node $$$i$$$.</p><p>She wants to maximize the number of nodes she can choose in the first turn which will guarantee her a win. Help Eikooc find any relabeling which will help her do so. </p>","ru":"<p>Eikooc и Sushi играют в игру.</p><p>Игра проводится на дереве из $$$n$$$ вершин, пронумерованных от $$$1$$$ до $$$n$$$. Напомним, что дерево с $$$n$$$ вершинами это неориентированный связный граф с $$$n-1$$$ ребрами.</p><p>Игроки поочередно перемещают фишку по дереву. <span class=\"tex-font-style-bf\">Eikooc делает первый ход, помещая фишку</span> на любую вершину по своему выбору. Sushi делает следующий ход, затем Eikooc, затем Sushi, и так далее. В каждый ход после первого, игрок должен переместить фишку в какую-то вершину $$$u$$$ такую, что: </p><ul> <li> Между вершинами $$$u$$$ и $$$v$$$ (на которой фишка находится данный момент), есть ребро </li><li> $$$u$$$ не была посещена ранее </li><li> $$$u \\oplus v \\leq min(u, v)$$$ </li></ul><p>Здесь $$$x \\oplus y$$$ обозначает операцию <a href=\"https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_исключающее_ИЛИ\">побитового исключающего ИЛИ</a> чисел $$$x$$$ и $$$y$$$.</p><p>Оба игрока играют оптимально. Игрок, который не может сделать ход, проигрывает.</p><p>Ниже приведены примеры, демонстрирующие правила игры. </p><center> <table class=\"tex-tabular\"><tbody><tr><td class=\"tex-tabular-text-align-left\"><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/107ba882ed591b6400d184844f1f55fff62aa396.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"> </center> <span class=\"tex-font-style-it\">Предположим, Eikooc начинает игру, помещая фишку в вершину $$$4$$$. Затем Sushi перемещает фишку в вершину $$$6$$$, которая не была посещена и является соседней к $$$4$$$. Также $$$6 \\oplus 4 = 2 \\leq min(6, 4)$$$. На следующем ходу Eikooc перемещает фишку в вершину $$$5$$$, которая не была посещена и является соседней к $$$6$$$. Также, $$$5 \\oplus 6 = 3 \\leq min(5, 6)$$$. У Sushi больше нет ходов для игры, поэтому она проигрывает</span>.</td><td class=\"tex-tabular-text-align-left\"><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/18ae9665746e40473d24b2ec70728892d0cb7364.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"> </center> <span class=\"tex-font-style-it\">Предположим, Eikooc начинает игру, помещая фишку в вершинул $$$3$$$. Sushi перемещает фишку в вершину $$$2$$$, которая не была посещена и является соседней к $$$3$$$. Также $$$3 \\oplus 2 = 1 \\leq min(3, 2)$$$. Eikooc не может переместить фишку в вершину $$$6$$$, так как $$$6 \\oplus 2 = 4 \\nleq min(6, 2)$$$. Поскольку у Eikooc нет ходов для игры, она проигрывает</span>.</td></tr></tbody></table> </center><p>Перед началом игры Eikooc решает тайком перенумеровать вершины дерева в свою пользу. Формально, перенумерация — это перестановка $$$p$$$ длины $$$n$$$ (последовательность из $$$n$$$ целых чисел, где каждое целое число от $$$1$$$ до $$$n$$$ встречается ровно один раз), где $$$p_i$$$ обозначает новый номер вершины $$$i$$$.</p><p>Она хочет максимизировать количество вершин, которые она может выбрать в первый ход, для которых она сможет гарантировать себе победу. Помогите Eikooc найти любую перенумерацию, которая поможет ей в этом. </p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The first line contains a single integer $$$t~(1 \\le t \\le 10^5)$$$ &nbsp;— the number of test cases. The description of each test case is as follows.</p><p>The first line of each test case contains an integer $$$n~(1 \\le n \\le 2 \\cdot 10^5)$$$ &nbsp;— the number of nodes in the tree.</p><p>The next $$$n-1$$$ lines contain two integers $$$u$$$ and $$$v$$$ $$$(1 \\le u, v \\le n; u \\neq v)$$$ &nbsp;— denoting an edge between nodes $$$u$$$ and $$$v$$$.</p><p>It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>Первая строка содержит одно целое число $$$t~(1 \\le t \\le 10^5)$$$ &nbsp;— количество наборов входных данных. Описание каждого набора входных данных выглядит следующим образом.</p><p>Первая строка каждого набора входных данных содержит целое число $$$n~(1 \\le n \\le 2 \\cdot 10^5)$$$ &nbsp;— количество вершин в дереве.</p><p>Следующие $$$n-1$$$ строки содержат по два целых числа $$$u$$$ и $$$v$$$ $$$(1 \\le u, v \\le n; u \\neq v)$$$ &nbsp;— обозначающие ребро между вершинами $$$u$$$ и $$$v$$$.</p><p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных не превышает $$$2 \\cdot 10^5$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>For each test case print any suitable relabeling &nbsp;— a permutation of length $$$n$$$ which maximizes the number of nodes that can be chosen in the first turn that guarantee a win for Eikooc. If there are multiple such relabelings, you may print any of them.</p>","ru":"<div class=\"section-title\">Выходные данные</div><p>Для каждого набора входных данных выведите любую подходящую перестановку &nbsp;— перестановку длины $$$n$$$, которая максимизирует количество вершин, которые Eikooc может выбрать в первый ход и иметь выиграшную стратегию. Если таких перестановок несколько, вы можете вывести любую из них.</p>"},"noteHtml":{"en":"<div class=\"section-title\">Note</div><p>In the first test case, Eikooc has only one choice. Sushi will have no moves to play after Eikooc chooses this node and Eikooc will win.</p><p>In the second test case, $$$1 \\oplus 2 = 3 \\nleq min(1, 2)$$$. Hence, after Eikooc picks either of the nodes, Sushi will have no moves to play and Eikooc will win. Both $$$\\{1, 2\\}$$$ and $$$\\{2, 1\\}$$$ are optimal relabelings.</p>","ru":"<div class=\"section-title\">Примечание</div><p>В первом наборе входных данных у Eikooc есть только одна вершина. У Sushi не будет ходов после того, как Eikooc выберет эту вершину, и Eikooc выиграет.</p><p>Во втором наборе входных данных $$$1 \\oplus 2 = 3 \\nleq min(1, 2)$$$. Следовательно, после того, как Eikooc выберет любую из вершин, у Sushi не останется ходов, и Eikooc выиграет. И $$$\\{1, 2\\}$$$, и $$$\\{2, 1\\}$$$ являются допустимыми перенумерациями.</p>"},"sampleTestcases":[{"id":1636727728207,"input":"3\n1\n2\n1 2\n3\n1 2\n1 3\n","output":"1\n2 1\n1 2 3\n"}],"submitUrl":"https://codeforces.com/contest/1605/submit","language":"c++","isPartOfContest":true}