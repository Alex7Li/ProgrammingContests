{"title":{"en":"D. Rigged Roads","ru":"D. Rigged Roads"},"contestId":"353907","problemIndex":"D","timeLimit":{"en":"2 seconds","ru":"2 seconds"},"memLimit":{"en":"256 megabytes","ru":"256 megabytes"},"inputFormat":{"en":"standard input","ru":"standard input"},"outputFormat":{"en":"standard output","ru":"standard output"},"problemHtml":{"en":"<p>Silvermill is on a tight budget lately, and Peanut, its mayor, is intending to demolish some roads to save on maintenance costs. Silvermill can be described as a city with $$$N$$$ road intersections and $$$E$$$ roads running between them, with the $$$i$$$th road connecting intersections $$$A_i$$$ and $$$B_i$$$. Each road intersection is labelled from $$$1$$$, . . . , $$$N$$$ and each road is labelled from $$$1$$$, . . . , $$$E$$$. It is guaranteed it is possible to travel between any pair of road intersections directly or indirectly, and no two roads share the same endpoints. </p><p>To facilitate this effort, Peanut has hired you to help assess the maintenance cost of the roads. The task from Peanut is as follows: You need to report a list $$$W = (W_1, W_2, . . . , W_E)$$$ such that $$$W$$$ is a permutation of $$$1, . . . , E$$$ and $$$W_i$$$ is the cost to keep the $$$i$$$th road.</p><p>Peanut will then pick a subset of roads to keep such that: </p><ul> <li> All the road intersections remain connected. </li><li> The sum of costs of the kept roads are minimised. </li></ul><p>In other words, Peanut will keep the minimum spanning tree, based on the weights given by you. Note that the minimum spanning tree is unique since the costs are distinct.</p><p>Unknown to Peanut, you have a hidden agenda. You wish to keep a subset $$$R$$$ of roads that form a spanning tree. Notice that you can convince Peanut to pick $$$R$$$ by carefully choosing $$$W$$$. Your goal is to find the lexicographically smallest permutation $$$W$$$ that satisfies the above condition.</p><p>In summary, given a subset $$$R$$$ of roads that forms a spanning tree, find the lexicographically smallest weight assignment $$$W$$$ such that the minimum spanning tree of the city is R.</p>","ru":"<p>Silvermill is on a tight budget lately, and Peanut, its mayor, is intending to demolish some roads to save on maintenance costs. Silvermill can be described as a city with $$$N$$$ road intersections and $$$E$$$ roads running between them, with the $$$i$$$th road connecting intersections $$$A_i$$$ and $$$B_i$$$. Each road intersection is labelled from $$$1$$$, . . . , $$$N$$$ and each road is labelled from $$$1$$$, . . . , $$$E$$$. It is guaranteed it is possible to travel between any pair of road intersections directly or indirectly, and no two roads share the same endpoints. </p><p>To facilitate this effort, Peanut has hired you to help assess the maintenance cost of the roads. The task from Peanut is as follows: You need to report a list $$$W = (W_1, W_2, . . . , W_E)$$$ such that $$$W$$$ is a permutation of $$$1, . . . , E$$$ and $$$W_i$$$ is the cost to keep the $$$i$$$th road.</p><p>Peanut will then pick a subset of roads to keep such that: </p><ul> <li> All the road intersections remain connected. </li><li> The sum of costs of the kept roads are minimised. </li></ul><p>In other words, Peanut will keep the minimum spanning tree, based on the weights given by you. Note that the minimum spanning tree is unique since the costs are distinct.</p><p>Unknown to Peanut, you have a hidden agenda. You wish to keep a subset $$$R$$$ of roads that form a spanning tree. Notice that you can convince Peanut to pick $$$R$$$ by carefully choosing $$$W$$$. Your goal is to find the lexicographically smallest permutation $$$W$$$ that satisfies the above condition.</p><p>In summary, given a subset $$$R$$$ of roads that forms a spanning tree, find the lexicographically smallest weight assignment $$$W$$$ such that the minimum spanning tree of the city is R.</p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The input starts with a line with two integers $$$N$$$ and $$$E$$$.</p><p>$$$E$$$ lines will follow. The $$$i$$$th line contains two integers, $$$A_i$$$ and $$$B_i$$$, describing a single road.</p><p>The last line of input will contain $$$N − 1$$$ integers, the labels of roads in $$$R$$$, the set of roads you wish to keep</p><ul> <li> $$$1 \\leq N, E \\leq 3 ∗ 10^5$$$ </li><li> $$$1 \\leq A_i \\neq B_i \\leq N$$$ </li><li> $$$1 \\leq R_i \\leq N$$$ </li><li> It is possible to travel between any two road intersections using only roads in $$$R$$$. </li></ul>","ru":"<div class=\"section-title\">Input</div><p>The input starts with a line with two integers $$$N$$$ and $$$E$$$.</p><p>$$$E$$$ lines will follow. The $$$i$$$th line contains two integers, $$$A_i$$$ and $$$B_i$$$, describing a single road.</p><p>The last line of input will contain $$$N − 1$$$ integers, the labels of roads in $$$R$$$, the set of roads you wish to keep</p><ul> <li> $$$1 \\leq N, E \\leq 3 ∗ 10^5$$$ </li><li> $$$1 \\leq A_i \\neq B_i \\leq N$$$ </li><li> $$$1 \\leq R_i \\leq N$$$ </li><li> It is possible to travel between any two road intersections using only roads in $$$R$$$. </li></ul>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>The output should contain $$$E$$$ integers on a single line, the lexicographically minimal permutation $$$W$$$ that would result in $$$R$$$ being selected as the minimum spanning tree.</p>","ru":"<div class=\"section-title\">Output</div><p>The output should contain $$$E$$$ integers on a single line, the lexicographically minimal permutation $$$W$$$ that would result in $$$R$$$ being selected as the minimum spanning tree.</p>"},"noteHtml":{"en":null,"ru":null},"sampleTestcases":[{"id":1636588865623,"input":"4 5\n3 4\n1 2\n2 3\n1 3\n1 4\n2 4 5","output":"3 4 5 1 2 ","result":{"id":1636588865623,"stdout":"3 4 5 1 2\n","stderr":"","exitcode":0,"signal":null,"time":2,"timeout":false}},{"id":1636588865624,"input":"4 4\n1 2\n1 4\n2 3\n3 4\n1 3 4","output":"1 4 2 3 ","result":{"id":1636588865624,"stdout":"1 4 2 3\n","stderr":"","exitcode":0,"signal":null,"time":0,"timeout":false}},{"id":1636594660215,"input":"5 5\n5 1\n1 2\n2 3\n3 4\n4 5\n2 3 4 5","output":"5 1 2 3 4","result":{"id":1636594660215,"stdout":"5 1 2 3 4\n","stderr":"","exitcode":0,"signal":null,"time":1,"timeout":false}},{"id":1636595868610,"input":"5 5\n1 5\n2 4\n1 2\n2 3\n3 4\n1 3 4 5","output":"1 4 5 2 3","result":{"id":1636595868610,"stdout":"1 4 5 2 3\n","stderr":"","exitcode":0,"signal":null,"time":3,"timeout":false}},{"id":1636596399415,"input":"5 5\n2 1\n1 3\n1 4\n5 1\n1 5\n1 2 3 4","output":"1 2 3 4 5","result":{"id":1636596399415,"stdout":"1 2 3 4 5\n","stderr":"","exitcode":0,"signal":null,"time":3,"timeout":false}},{"id":1636596417033,"input":"5 6\n1 2\n2 3\n3 4\n4 5\n2 4\n4 1\n1 2 3 4","output":"1 2 3 4 5 6","result":{"id":1636596417033,"stdout":"1 2 3 4 5 6\n","stderr":"","exitcode":0,"signal":null,"time":1,"timeout":false}},{"id":1636597249234,"input":"2 1\n1 2\n1","output":"1","result":{"id":1636597249234,"stdout":"1\n","stderr":"","exitcode":0,"signal":null,"time":1,"timeout":false}}],"submitUrl":"https://codeforces.com/group/KIrM1Owd8u/contest/353907/submit","language":"c++","isPartOfContest":true,"langId":"54"}