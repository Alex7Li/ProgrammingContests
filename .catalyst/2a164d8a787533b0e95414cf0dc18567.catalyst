{"title":{"en":"E. Nearest Opposite Parity","ru":"E. Ближайшая противоположная четность"},"contestId":"1272","problemIndex":"E","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"256 megabytes","ru":"256 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p>You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move, you can jump from the position $$$i$$$ to the position $$$i - a_i$$$ (if $$$1 \\le i - a_i$$$) or to the position $$$i + a_i$$$ (if $$$i + a_i \\le n$$$).</p><p>For each position $$$i$$$ from $$$1$$$ to $$$n$$$ you want to know the minimum the number of moves required to reach any position $$$j$$$ such that $$$a_j$$$ has the opposite parity from $$$a_i$$$ (i.e. if $$$a_i$$$ is odd then $$$a_j$$$ has to be even and vice versa).</p>","ru":"<p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ целых чисел. За один ход вы можете прыгнуть с позиции $$$i$$$ в позицию $$$i - a_i$$$ (если $$$1 \\le i - a_i$$$) или в позицию $$$i + a_i$$$ (если $$$i + a_i \\le n$$$).</p><p>Для каждой позиции $$$i$$$ от $$$1$$$ до $$$n$$$ вы хотите узнать минимальное количество ходов, необходимое, чтобы достичь любой позиции $$$j$$$ такой, что $$$a_j$$$ имеет четность, отличающуюся от четности $$$a_i$$$ (то есть если $$$a_i$$$ нечетно, то $$$a_j$$$ должно быть четным и наоборот).</p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of elements in $$$a$$$.</p><p>The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le n$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>Первая строка входных данных содержит одно целое число $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — количество элементов в $$$a$$$.</p><p>Вторая строка входных данных содержит $$$n$$$ целых чисел $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le n$$$), где $$$a_i$$$ равно $$$i$$$-му элементу $$$a$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>Print $$$n$$$ integers $$$d_1, d_2, \\dots, d_n$$$, where $$$d_i$$$ is the minimum the number of moves required to reach any position $$$j$$$ such that $$$a_j$$$ has the opposite parity from $$$a_i$$$ (i.e. if $$$a_i$$$ is odd then $$$a_j$$$ has to be even and vice versa) or <span class=\"tex-font-style-tt\">-1</span> if it is impossible to reach such a position.</p>","ru":"<div class=\"section-title\">Выходные данные</div><p>Выведите $$$n$$$ целых чисел $$$d_1, d_2, \\dots, d_n$$$, где $$$d_i$$$ равно минимальному количеству ходов, необходимому, чтобы достичь любой позиции $$$j$$$ такой, что $$$a_j$$$ имеет четность, отличающуюся от четности $$$a_i$$$ (то есть если $$$a_i$$$ нечетно, то $$$a_j$$$ должно быть четным и наоборот) или же <span class=\"tex-font-style-tt\">-1</span>, если такой позиции достичь невозможно.</p>"},"noteHtml":{"en":null,"ru":null},"sampleTestcases":[{"id":1634094142917,"input":"10\n4 5 7 6 7 5 4 4 6 4","output":"1 1 1 2 -1 1 1 3 1 1 \n","result":{"id":1634094142917,"stdout":"1 1 1 2 -1 1 1 3 1 1\n","stderr":"","exitcode":0,"signal":null,"time":41,"timeout":false}}],"submitUrl":"https://codeforces.com/problemset/submit","language":"python","langId":"41","editorial":"<div><p>In this problem, we have directed graph consisting of $$$n$$$ vertices (indices of the array) and at most $$$2n-2$$$ edges. Some vertices have the value $$$0$$$, some have the value $$$1$$$. Our problem is to find for every vertex the nearest vertex having the opposite parity. Let's try to solve the problem for odd numbers and then just run the same algorithm with even numbers.</p><p>We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices. This problem can be solved with the standard and simple but pretty idea. Let's inverse our graph and run a multi-source breadth-first search from all even vertices. The only difference between standard bfs and multi-source bfs is that the second one have many vertices at the first step (vertices having zero distance).</p><p>Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph. This is exactly what we need. Then just run the same algorithm for even numbers and print the answer.</p><p>Time complexity: $$$O(n)$$$.</p></div>"}