<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Ohio State ACM-ICPC Team Notebook: Sublinear Substring Seekers</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<CENTER><H1><U>Ohio State ACM-ICPC Team Notebook: Sublinear Substring Seekers</U></H1></CENTER>
<H1>Table of Contents</H1>
<H2>Essentials</H2>

<OL START=1>
<LI><A HREF="#file1">C++ header</A></LI>
<LI><A HREF="#file2">C++ flags</A></LI>
<LI><A HREF="#file3">C++ input/output</A></LI>
</OL>
<H2>Data structures</H2>

<OL START=4>
<LI><A HREF="#file4">Unordered Set/Map</A></LI>
<LI><A HREF="#file5">Ordered Set/Map</A></LI>
<LI><A HREF="#file6">Suffix array</A></LI>
<LI><A HREF="#file7">Disjoint Union Find (w/Rollback)</A></LI>
<LI><A HREF="#file8">KD-tree</A></LI>
<LI><A HREF="#file9">Segment tree</A></LI>
<LI><A HREF="#file10">Lazy segment tree</A></LI>
<LI><A HREF="#file11">Lowest common ancestor</A></LI>
<LI><A HREF="#file12">Li Chao Tree</A></LI>
</OL>
<H2>Combinatorial optimization</H2>

<OL START=13>
<LI><A HREF="#file13">Sparse max-flow</A></LI>
<LI><A HREF="#file14">Min-cost max-flow</A></LI>
<LI><A HREF="#file15">Min-cost matching</A></LI>
<LI><A HREF="#file16">Max bipartite matching</A></LI>
<LI><A HREF="#file17">Global min-cut</A></LI>
</OL>
<H2>Geometry</H2>

<OL START=18>
<LI><A HREF="#file18">Python geometry</A></LI>
<LI><A HREF="#file19">3D geometry</A></LI>
<LI><A HREF="#file20">Slow Delaunay triangulation</A></LI>
</OL>
<H2>Numerical algorithms</H2>

<OL START=21>
<LI><A HREF="#file21">Number theory (modular, Chinese remainder, linear Diophantine)</A></LI>
<LI><A HREF="#file22">Modular Arithmetic</A></LI>
<LI><A HREF="#file23">Systems of linear equations, matrix inverse, determinant</A></LI>
<LI><A HREF="#file24">Reduced row echelon form, matrix rank</A></LI>
<LI><A HREF="#file25">Fast Fourier transform</A></LI>
<LI><A HREF="#file26">Euler's Toitent Function</A></LI>
<LI><A HREF="#file27">Partitions</A></LI>
</OL>
<H2>Graph algorithms</H2>

<OL START=28>
<LI><A HREF="#file28">Bellman-Ford shortest paths with negative edge weights (C++)</A></LI>
<LI><A HREF="#file29">Topological sort (C++)</A></LI>
<LI><A HREF="#file30">Fast Dijkstra's algorithm</A></LI>
<LI><A HREF="#file31">Strongly connected components</A></LI>
<LI><A HREF="#file32">Eulerian path</A></LI>
<LI><A HREF="#file33">Minimum spanning trees</A></LI>
</OL>
<H2>Strings</H2>

<OL START=34>
<LI><A HREF="#file34">AhoCorasick</A></LI>
<LI><A HREF="#file35">Longest increasing subsequence</A></LI>
<LI><A HREF="#file36">Longest common subsequence</A></LI>
<LI><A HREF="#file37">Knuth-Morris-Pratt</A></LI>
<LI><A HREF="#file38">Longest Common Prefix</A></LI>
<LI><A HREF="#file39">Palindromes</A></LI>
</OL>
<H2>Miscellaneous</H2>

<OL START=40>
<LI><A HREF="#file40">Prime numbers</A></LI>
<LI><A HREF="#file41">Binary Search</A></LI>
<LI><A HREF="#file42">Latitude/longitude</A></LI>
<LI><A HREF="#file43">Hilbert curve for Mo's Algorithm</A></LI>
</OL>
<HR>
<A NAME="file1">
<H1>code/cppheader.cc 1/43</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">rep</FONT></B>(i, a, b) for(int i = a; i &lt; (b); ++i)
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">trav</FONT></B>(a, x) for(auto&amp; a : x)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ll;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; pii;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;</PRE>
<HR>
<A NAME="file2">
<H1>code/DebugHeader.txt 2/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
# Add this to the CMakeLists in CLion to crash with bad memory accesses and give better warnings.
# Don't include this comment, comments don't work in CMakeLists.
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -Wextra -Wno-sign-compare -D _GLIBCXX_DEBUG -D _GLIBCXX_DEBUG_PEDANTIC &quot;)
</PRE>
<HR>
<A NAME="file3">
<H1>code/IO.cc 3/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bitset&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

    <I><FONT COLOR="#B22222">// Output a specific number of digits past the decimal point,
</FONT></I>    <I><FONT COLOR="#B22222">// in this case 5    
</FONT></I>    cout.setf(ios::fixed);
    cout &lt;&lt; setprecision(5);
    cout &lt;&lt; 100.0 / 7.0 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; 10.0 &lt;&lt; endl; <I><FONT COLOR="#B22222">// 14.28571 10.00000
</FONT></I>    cout.unsetf(ios::fixed);

    <I><FONT COLOR="#B22222">// Output a '+' before positive values
</FONT></I>    cout.setf(ios::showpos);
    cout &lt;&lt; 100 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; -100 &lt;&lt; endl; <I><FONT COLOR="#B22222">// +100 -100
</FONT></I>    cout.unsetf(ios::showpos);

    <I><FONT COLOR="#B22222">// Output numerical values in hexadecimal. Also works for oct
</FONT></I>    cout &lt;&lt; hex &lt;&lt; 500 &lt;&lt; dec &lt;&lt; endl; <I><FONT COLOR="#B22222">// 1f4 (1*256 + 15*16 + 4*1)
</FONT></I>    <I><FONT COLOR="#B22222">// Output numerical values in binary
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::bitset&lt;10&gt; bs(500);
    cout &lt;&lt; bs &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0111110100
</FONT></I>
    <I><FONT COLOR="#B22222">// Read until end of file.
</FONT></I>    string line;
    getline(cin, line);
    <B><FONT COLOR="#A020F0">while</FONT></B> (!line.empty()) { <I><FONT COLOR="#B22222">// Input in CP problems always ends with an empty line.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> intV; string stringV;
        stringstream line_stream(line);
        line_stream &gt;&gt; stringV &gt;&gt; intV; <I><FONT COLOR="#B22222">// Just read like usual from the stream
</FONT></I>        getline(cin, line);
    }
}
</PRE>
<HR>
<A NAME="file4">
<H1>code/UnorderedSetMap.cc 4/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// An example of policy hashtable with a custom object in cpp. It is
</FONT></I><I><FONT COLOR="#B22222">// it is better than the built in unordered_map in that
</FONT></I><I><FONT COLOR="#B22222">// it is ~5 times faster. (https://codeforces.com/blog/entry/60737)
</FONT></I><I><FONT COLOR="#B22222">// No real downsides (normal map is just as annoying with custom objects),
</FONT></I><I><FONT COLOR="#B22222">// but be careful with the hash function, the number of buckets is a power of 2.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> Coordinate {
    <B><FONT COLOR="#228B22">int</FONT></B> x;
    <B><FONT COLOR="#228B22">int</FONT></B> y;
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;other) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> x == other.x &amp;&amp; y == other.y;
    }
};

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;stream, <B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) {
    <B><FONT COLOR="#A020F0">return</FONT></B> stream &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B> &lt;&lt; l.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; l.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/assoc_container.hpp&gt;</FONT></B>

<B><FONT COLOR="#228B22">struct</FONT></B> chash {
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> c = uint64_t(7e18) + 13; <I><FONT COLOR="#B22222">// Big prime
</FONT></I>    uint64_t <B><FONT COLOR="#A020F0">operator</FONT></B>()(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> __builtin_bswap64((l.x + l.y) * c);
    }
};

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k, <B><FONT COLOR="#228B22">class</FONT></B> v&gt;
using hash_map = __gnu_pbds::gp_hash_table&lt;k, v, chash&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k&gt;
using hash_set = __gnu_pbds::gp_hash_table&lt;k, __gnu_pbds::null_type, chash&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename k, typename v&gt;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">contains</FONT></B>(hash_map&lt;k, v&gt; map, k val) {
    <B><FONT COLOR="#A020F0">return</FONT></B> map.find(val) != map.end();
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// After importing, writing the template code, overloading ==
</FONT></I>    <I><FONT COLOR="#B22222">// and &lt;&lt; (print) operator like above, you can use the map
</FONT></I>    hash_map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; my_map;
    my_map[{1, 2}] = 17;
    cout &lt;&lt; my_map[{1, 2}] &lt;&lt; endl; <I><FONT COLOR="#B22222">// Prints 17
</FONT></I>    assert(contains(my_map, {1, 2}));
    assert(!contains(my_map, {3, 4}));
    cout &lt;&lt; my_map[{3, 4}] &lt;&lt; endl; <I><FONT COLOR="#B22222">// Prints 0
</FONT></I>    assert(my_map.size() == 2); <I><FONT COLOR="#B22222">// We just set {3, 4} to 0 by accessing it.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> pair : my_map) {
        cout &lt;&lt; pair.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;=&quot;</FONT></B> &lt;&lt; pair.second &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; <I><FONT COLOR="#B22222">// {3 4}=0 {1 2}=17
</FONT></I>    }

    hash_set&lt;Coordinate&gt; my_set;
    assert(my_set.empty());
    my_set.insert({1, 2});
    assert(contains(my_set, {1, 2}));
    my_set.insert({4, 5});
    <I><FONT COLOR="#B22222">// hash_set does the correct thing, and when you iterate over it you get keys,
</FONT></I>    <I><FONT COLOR="#B22222">// not key-value pairs with a null value.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> it = my_set.begin(); it != my_set.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;  <I><FONT COLOR="#B22222">// print {4, 5} {1, 2}.
</FONT></I>    }
    <I><FONT COLOR="#B22222">// Standard C Library Equivalent Declarations:
</FONT></I>    <I><FONT COLOR="#B22222">// unordered_map&lt;Coordinate, int, chash&gt; my_map;
</FONT></I>    <I><FONT COLOR="#B22222">// unordered_set&lt;Coordinate, chash&gt; my_set;
</FONT></I>}</PRE>
<HR>
<A NAME="file5">
<H1>code/OrderedSetMap.cc 5/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// An example of using an ordered map with a custom object.
</FONT></I><I><FONT COLOR="#B22222">// Also include code for the gnu policy tree, which gives
</FONT></I><I><FONT COLOR="#B22222">// a easy (~2x slower) segment tree by implementing
</FONT></I><I><FONT COLOR="#B22222">// find_by_order and order_of_key
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> Coordinate {
    <B><FONT COLOR="#228B22">int</FONT></B> x;
    <B><FONT COLOR="#228B22">int</FONT></B> y;
    <I><FONT COLOR="#B22222">// Overloaded for ordered map. If !(c1&lt;c2), !(c2&lt;c1), then
</FONT></I>    <I><FONT COLOR="#B22222">// c1 will be considered equal to c2.
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> x == o.x ? y &lt; o.y : x &lt; o.x;
    }
};

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;stream, <B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) {
    <B><FONT COLOR="#A020F0">return</FONT></B> stream &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B> &lt;&lt; l.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; l.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>;
}

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/assoc_container.hpp&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/tree_policy.hpp&gt;</FONT></B>

using namespace __gnu_pbds;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k, <B><FONT COLOR="#228B22">class</FONT></B> v&gt;
using ordered_map = tree&lt;k, v, less&lt;k&gt;,
        rb_tree_tag, <I><FONT COLOR="#B22222">// Red black tree. Can use splay_tree_tag for a splay tree,
</FONT></I>        <I><FONT COLOR="#B22222">// but split operation for splay is linear time so it may be terrible.
</FONT></I>        tree_order_statistics_node_update <I><FONT COLOR="#B22222">// To get find_by_order and order_of_key methods
</FONT></I>&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k&gt; <I><FONT COLOR="#B22222">// Same as ordered map almost
</FONT></I>using ordered_set = tree&lt;k, null_type, less&lt;k&gt;,
        rb_tree_tag, tree_order_statistics_node_update&gt;;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; c_map; <I><FONT COLOR="#B22222">// Standard C Library Ordered Map
</FONT></I>    set&lt;Coordinate&gt; c_set; <I><FONT COLOR="#B22222">// Standard C Library Ordered Set
</FONT></I>    ordered_map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; gnu_map; <I><FONT COLOR="#B22222">// Gnu map declaration
</FONT></I>    ordered_set&lt;Coordinate&gt; gnu_set;<I><FONT COLOR="#B22222">// Gnu set declaration
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 10; i++) {
        gnu_set.insert({0, i * 10});
    }
    cout &lt;&lt; *gnu_set.find({0, 30}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 30}
</FONT></I>    cout &lt;&lt; *gnu_set.lower_bound({0, 53}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    cout &lt;&lt; *gnu_set.upper_bound({0, 53}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    cout &lt;&lt; *gnu_set.lower_bound({0, 50}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 50}
</FONT></I>    cout &lt;&lt; *gnu_set.upper_bound({0, 50}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    <I><FONT COLOR="#B22222">// Example of the operations only supported by gnu_set
</FONT></I>    cout &lt;&lt; *gnu_set.find_by_order(2) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0 20}
</FONT></I>    cout &lt;&lt; *gnu_set.find_by_order(4) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0 40}
</FONT></I>    assert(end(gnu_set) == gnu_set.find_by_order(10));
    cout &lt;&lt; gnu_set.order_of_key({0, -99}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 0}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 11}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 2
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 999}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 10
</FONT></I>}</PRE>
<HR>
<A NAME="file6">
<H1>code/SuffixArray.cc 6/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Suffix array construction in O(L log^2 L) time.  Routine for
</FONT></I><I><FONT COLOR="#B22222">// computing the length of the longest common prefix of any two
</FONT></I><I><FONT COLOR="#B22222">// suffixes in O(log L) time.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:   string s
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:  array suffix[] such that suffix[i] = index (from 0 to L-1)
</FONT></I><I><FONT COLOR="#B22222">//          of substring s[i...L-1] in the list of sorted suffixes.
</FONT></I><I><FONT COLOR="#B22222">//          That is, if we take the inverse of the permutation suffix[],
</FONT></I><I><FONT COLOR="#B22222">//          we get the actual suffix array.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> SuffixArray {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> L;
    string s;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; P;
    vector&lt;pair&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt;, <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; M;

    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s) : L(s.length()), s(s), P(1, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0)), M(L) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++) P[0][i] = <B><FONT COLOR="#228B22">int</FONT></B>(s[i]);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> skip = 1, level = 1; skip &lt; L; skip *= 2, level++) {
            P.push_back(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0));
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++)
                M[i] = make_pair(make_pair(P[level - 1][i], i + skip &lt; L ? P[level - 1][i + skip] : -1000), i);
            sort(M.begin(), M.end());
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++)
                P[level][M[i].second] = (i &gt; 0 &amp;&amp; M[i].first == M[i - 1].first) ? P[level][M[i - 1].second] : i;
        }
    }

    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; GetSuffixArray() { <B><FONT COLOR="#A020F0">return</FONT></B> P.back(); }

    <I><FONT COLOR="#B22222">// returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> LongestCommonPrefix(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
        <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (i == j) <B><FONT COLOR="#A020F0">return</FONT></B> L - i;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = P.size() - 1; k &gt;= 0 &amp;&amp; i &lt; L &amp;&amp; j &lt; L; k--) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (P[k][i] == P[k][j]) {
                i += 1 &lt;&lt; k;
                j += 1 &lt;&lt; k;
                len += 1 &lt;&lt; k;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> len;
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem 11512: GATTACA.
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> T;
    cin &gt;&gt; T;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> caseno = 0; caseno &lt; T; caseno++) {
        string s;
        cin &gt;&gt; s;
        SuffixArray array(s);
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = array.GetSuffixArray();
        <B><FONT COLOR="#228B22">int</FONT></B> bestlen = -1, bestpos = -1, bestcount = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; s.length(); i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> len = 0, count = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; s.length(); j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> l = array.LongestCommonPrefix(i, j);
                <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= len) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt; len) count = 2; <B><FONT COLOR="#A020F0">else</FONT></B> count++;
                    len = l;
                }
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; bestlen || len == bestlen &amp;&amp; s.substr(bestpos, bestlen) &gt; s.substr(i, len)) {
                bestlen = len;
                bestcount = count;
                bestpos = i;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (bestlen == 0) {
            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;No repetitions found!&quot;</FONT></B> &lt;&lt; endl;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            cout &lt;&lt; s.substr(bestpos, bestlen) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; bestcount &lt;&lt; endl;
        }
    }
}

#<B><FONT COLOR="#5F9EA0">else
</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

  <I><FONT COLOR="#B22222">// bobocel is the 0'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//  obocel is the 5'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//   bocel is the 1'st suffix
</FONT></I>  <I><FONT COLOR="#B22222">//    ocel is the 6'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//     cel is the 2'nd suffix
</FONT></I>  <I><FONT COLOR="#B22222">//      el is the 3'rd suffix
</FONT></I>  <I><FONT COLOR="#B22222">//       l is the 4'th suffix
</FONT></I>  SuffixArray suffix(<B><FONT COLOR="#BC8F8F">&quot;bobocel&quot;</FONT></B>);
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = suffix.GetSuffixArray();
  
  <I><FONT COLOR="#B22222">// Expected output: 0 5 1 6 2 3 4
</FONT></I>  <I><FONT COLOR="#B22222">//                  2
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
  cout &lt;&lt; endl;
  cout &lt;&lt; suffix.LongestCommonPrefix(0, 2) &lt;&lt; endl;
}
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file7">
<H1>code/UnionFind.cc 7/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Disjoint-set data structure.
 * Time: $O(alpha(N))$
 */</FONT></I>
<B><FONT COLOR="#228B22">struct</FONT></B> UF {
    <I><FONT COLOR="#B22222">// E is parent set number if positive, and the size if negative.
</FONT></I>    <I><FONT COLOR="#B22222">// If negative, it's the root of a set.
</FONT></I>    vi e;
    UF(<B><FONT COLOR="#228B22">int</FONT></B> n) : e(n, -1) {}
    <B><FONT COLOR="#228B22">bool</FONT></B> sameSet(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> find(a) == find(b); }
    <B><FONT COLOR="#228B22">int</FONT></B> size(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> -e[find(x)]; }
    <B><FONT COLOR="#228B22">int</FONT></B> find(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> e[x] &lt; 0 ? x : e[x] = find(e[x]); }
    <B><FONT COLOR="#228B22">int</FONT></B> find2(<B><FONT COLOR="#228B22">int</FONT></B> x) {<I><FONT COLOR="#B22222">// Dennis claims this iterative find method is faster
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B> (e[x] &gt;= 0) {
            e[x] = e[e[x]];
            x = e[x]
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> x;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> join(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
        a = find(a), b = find(b);
        <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        <B><FONT COLOR="#A020F0">if</FONT></B> (e[a] &gt; e[b]) swap(a, b);
        e[a] += e[b];
        e[b] = a;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
}
<I><FONT COLOR="#B22222">// Support undoing the last few operations. O(log N) insertions.
</FONT></I><I><FONT COLOR="#B22222">// This can be used along with a seg tree over the time
</FONT></I><I><FONT COLOR="#B22222">// axis to support arbitrary deletions for offline query problems.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> RollbackUF {
    vi e; vector&lt;pii&gt; st;
    RollbackUF(<B><FONT COLOR="#228B22">int</FONT></B> n) : e(n, -1) {}
    <B><FONT COLOR="#228B22">int</FONT></B> size(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> -e[find(x)]; }
    <B><FONT COLOR="#228B22">int</FONT></B> find(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> e[x] &lt; 0 ? x : find(e[x]); }
    <B><FONT COLOR="#228B22">int</FONT></B> time() { <B><FONT COLOR="#A020F0">return</FONT></B> sz(st); }
    <B><FONT COLOR="#228B22">void</FONT></B> rollback(<B><FONT COLOR="#228B22">int</FONT></B> t) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = time(); i --&gt; t;)
            e[st[i].first] = st[i].second;
        st.resize(t);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> join(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
        a = find(a), b = find(b);
        <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        <B><FONT COLOR="#A020F0">if</FONT></B> (e[a] &gt; e[b]) swap(a, b);
        st.push_back({a, e[a]});
        st.push_back({b, e[b]});
        e[a] += e[b]; e[b] = a;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
};</PRE>
<HR>
<A NAME="file8">
<H1>code/KDTree.cc 8/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// -----------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// A straightforward, but probably sub-optimal KD-tree implmentation
</FONT></I><I><FONT COLOR="#B22222">// that's probably good enough for most things (current it's a
</FONT></I><I><FONT COLOR="#B22222">// 2D-tree)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  - constructs from n points in O(n lg^2 n) time
</FONT></I><I><FONT COLOR="#B22222">//  - handles nearest-neighbor query in O(lg n) if points are well
</FONT></I><I><FONT COLOR="#B22222">//    distributed
</FONT></I><I><FONT COLOR="#B22222">//  - worst case for nearest-neighbor may be linear in pathological
</FONT></I><I><FONT COLOR="#B22222">//    case
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Sonny Chan, Stanford University, April 2009
</FONT></I><I><FONT COLOR="#B22222">// -----------------------------------------------------------------
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>

using namespace std;

<I><FONT COLOR="#B22222">// number type for coordinates, and its maximum value
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ntype;
<B><FONT COLOR="#228B22">const</FONT></B> ntype sentry = numeric_limits&lt;ntype&gt;::max();

<I><FONT COLOR="#B22222">// point structure for 2D-tree, can be extended to 3D
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> point {
    ntype x, y;
    point(ntype xx = 0, ntype yy = 0) : x(xx), y(yy) {}
};

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x == b.x &amp;&amp; a.y == b.y;
}
<I><FONT COLOR="#B22222">// sorts points on x-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_x</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x &lt; b.x;
}
<I><FONT COLOR="#B22222">// sorts points on y-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_y</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.y &lt; b.y;
}
<I><FONT COLOR="#B22222">// squared distance between points
</FONT></I>ntype <B><FONT COLOR="#0000FF">pdist2</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    ntype dx = a.x - b.x, dy = a.y - b.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> dx * dx + dy * dy;
}

<I><FONT COLOR="#B22222">// bounding box for a set of points
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> bbox {
    ntype x0, x1, y0, y1;
    bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) {}
    <I><FONT COLOR="#B22222">// computes bounding box from a bunch of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> compute(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;v) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); ++i) {
            x0 = min(x0, v[i].x);
            x1 = max(x1, v[i].x);
            y0 = min(y0, v[i].y);
            y1 = max(y1, v[i].y);
        }
    }
    <I><FONT COLOR="#B22222">// squared distance between a point and this bbox, 0 if inside
</FONT></I>    ntype distance(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &lt; x0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, p.y), p);
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &gt; x1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, p.y), p);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        }
    }
};

<I><FONT COLOR="#B22222">// stores a single node of the kd-tree, either internal or leaf
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdnode {
    <B><FONT COLOR="#228B22">bool</FONT></B> leaf;      <I><FONT COLOR="#B22222">// true if this is a leaf node (has one point)
</FONT></I>    point pt;       <I><FONT COLOR="#B22222">// the single point of this is a leaf
</FONT></I>    bbox bound;     <I><FONT COLOR="#B22222">// bounding box for set of points in children
</FONT></I>
    kdnode *first, *second; <I><FONT COLOR="#B22222">// two children of this kd-node
</FONT></I>
    kdnode() : leaf(false), first(0), second(0) {}
    ~kdnode() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (first) <B><FONT COLOR="#A020F0">delete</FONT></B> first;
        <B><FONT COLOR="#A020F0">if</FONT></B> (second) <B><FONT COLOR="#A020F0">delete</FONT></B> second;
    }
    <I><FONT COLOR="#B22222">// intersect a point with this node (returns squared distance)
</FONT></I>    ntype intersect(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> bound.distance(p);
    }
    <I><FONT COLOR="#B22222">// recursively builds a kd-tree from a given cloud of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> construct(vector&lt;point&gt; &amp;vp) {
        <I><FONT COLOR="#B22222">// compute bounding box for points at this node
</FONT></I>        bound.compute(vp);

        <I><FONT COLOR="#B22222">// if we're down to one point, then we're a leaf node
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (vp.size() == 1) {
            leaf = true;
            pt = vp[0];
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">// split on x if the bbox is wider than high (not best heuristic...)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (bound.x1 - bound.x0 &gt;= bound.y1 - bound.y0)
                sort(vp.begin(), vp.end(), on_x);
                <I><FONT COLOR="#B22222">// otherwise split on y-coordinate
</FONT></I>            <B><FONT COLOR="#A020F0">else</FONT></B>
                sort(vp.begin(), vp.end(), on_y);

            <I><FONT COLOR="#B22222">// divide by taking half the array for each child
</FONT></I>            <I><FONT COLOR="#B22222">// (not best performance if many duplicates in the middle)
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> half = vp.size() / 2;
            vector&lt;point&gt; vl(vp.begin(), vp.begin() + half);
            vector&lt;point&gt; vr(vp.begin() + half, vp.end());
            first = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
            first-&gt;construct(vl);
            second = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
            second-&gt;construct(vr);
        }
    }
};

<I><FONT COLOR="#B22222">// simple kd-tree class to hold the tree and handle queries
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdtree {
    kdnode *root;
    <I><FONT COLOR="#B22222">// constructs a kd-tree from a points (copied here, as it sorts them)
</FONT></I>    kdtree(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;vp) {
        vector&lt;point&gt; v(vp.begin(), vp.end());
        root = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
        root-&gt;construct(v);
    }
    ~kdtree() { <B><FONT COLOR="#A020F0">delete</FONT></B> root; }
    <I><FONT COLOR="#B22222">// recursive search method returns squared distance to nearest point
</FONT></I>    ntype search(kdnode *node, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;leaf) {
            <I><FONT COLOR="#B22222">// commented special case tells a point not to find itself
</FONT></I><I><FONT COLOR="#B22222">//            if (p == node-&gt;pt) return sentry;
</FONT></I><I><FONT COLOR="#B22222">//            else               
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(p, node-&gt;pt);
        }

        ntype bfirst = node-&gt;first-&gt;intersect(p);
        ntype bsecond = node-&gt;second-&gt;intersect(p);

        <I><FONT COLOR="#B22222">// choose the side with the closest bounding box to search first
</FONT></I>        <I><FONT COLOR="#B22222">// (note that the other side is also searched if needed)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; bsecond) {
            ntype best = search(node-&gt;first, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bsecond &lt; best)
                best = min(best, search(node-&gt;second, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            ntype best = search(node-&gt;second, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; best)
                best = min(best, search(node-&gt;first, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        }
    }
    <I><FONT COLOR="#B22222">// squared distance to the nearest
</FONT></I>    ntype nearest(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> search(root, p);
    }
};

<I><FONT COLOR="#B22222">// --------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// some basic test code here
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// generate some random points for a kd-tree
</FONT></I>    vector&lt;point&gt; vp;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 100000; ++i) {
        vp.push_back(point(rand() % 100000, rand() % 100000));
    }
    kdtree tree(vp);

    <I><FONT COLOR="#B22222">// query some points
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 10; ++i) {
        point q(rand() % 100000, rand() % 100000);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Closest squared distance to (&quot;</FONT></B> &lt;&lt; q.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; q.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>
             &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; is &quot;</FONT></B> &lt;&lt; tree.nearest(q) &lt;&lt; endl;
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// --------------------------------------------------------------------------
</FONT></I></PRE>
<HR>
<A NAME="file9">
<H1>code/SegmentTree.cpp 9/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<B><FONT COLOR="#228B22">struct</FONT></B> Tree {
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> T;
    <B><FONT COLOR="#228B22">static</FONT></B> constexpr T unit = INT_MIN;
    T f(T a, T b) { <B><FONT COLOR="#A020F0">return</FONT></B> max(a, b); } <I><FONT COLOR="#B22222">// (any associative fn)
</FONT></I>    vector&lt;T&gt; s; <B><FONT COLOR="#228B22">int</FONT></B> n;
    Tree(<B><FONT COLOR="#228B22">int</FONT></B> n = 0, T def = unit) : s(2*n, def), n(n) {}
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> pos, T val) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> e) { <I><FONT COLOR="#B22222">// query [b, e)
</FONT></I>        T ra = unit, rb = unit;
        <B><FONT COLOR="#A020F0">for</FONT></B> (b += n, e += n; b &lt; e; b /= 2, e /= 2) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (b % 2) ra = f(ra, s[b++]);
            <B><FONT COLOR="#A020F0">if</FONT></B> (e % 2) rb = f(s[--e], rb);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> f(ra, rb);
    }
};</PRE>
<HR>
<A NAME="file10">
<H1>code/SegmentTreeLazy.cpp 10/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf = 1e9;
<I><FONT COLOR="#B22222">// A lazy segment tree supporting range add, range set, and range get max
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Node {
    Node *l = 0, *r = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> lo, hi, mset = inf, madd = 0, val = -inf;
    Node(<B><FONT COLOR="#228B22">int</FONT></B> lo,<B><FONT COLOR="#228B22">int</FONT></B> hi):lo(lo),hi(hi){} <I><FONT COLOR="#B22222">// Large interval of -inf
</FONT></I>    <I><FONT COLOR="#B22222">// Initialize based on the values in the vector v.
</FONT></I>    <I><FONT COLOR="#B22222">// main will call this with Node(v, 0, v.size())
</FONT></I>    Node(vi&amp; v, <B><FONT COLOR="#228B22">int</FONT></B> lo, <B><FONT COLOR="#228B22">int</FONT></B> hi) : lo(lo), hi(hi) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (lo + 1 &lt; hi) {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi - lo)/2;
            l = <B><FONT COLOR="#A020F0">new</FONT></B> Node(v, lo, mid); r = <B><FONT COLOR="#A020F0">new</FONT></B> Node(v, mid, hi);
            val = max(l-&gt;val, r-&gt;val);
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> val = v[lo];
    }
    <I><FONT COLOR="#B22222">// query [L, R)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> query(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B> -inf;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) <B><FONT COLOR="#A020F0">return</FONT></B> val;
        push();
        <B><FONT COLOR="#A020F0">return</FONT></B> max(l-&gt;query(L, R), r-&gt;query(L, R));
    }
    <I><FONT COLOR="#B22222">// set all elements in [L, R) to x
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> set(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) {
            <I><FONT COLOR="#B22222">// Update the range [lo, hi) to x
</FONT></I>            mset = val = x, madd = 0;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            push(), l-&gt;set(L, R, x), r-&gt;set(L, R, x);
            val = max(l-&gt;val, r-&gt;val);
        }
    }
    <I><FONT COLOR="#B22222">// add x to all elements in [L, R)
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> add(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) {
            <I><FONT COLOR="#B22222">// Add x to all elements in the range [lo, hi)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (mset != inf) mset += x;
            <B><FONT COLOR="#A020F0">else</FONT></B> madd += x;
            val += x;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            push(), l-&gt;add(L, R, x), r-&gt;add(L, R, x);
            val = max(l-&gt;val, r-&gt;val);
        }
    }
    <I><FONT COLOR="#B22222">// Push the lazily stored values.
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> push() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!l) {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi - lo)/2;
            l = <B><FONT COLOR="#A020F0">new</FONT></B> Node(lo, mid); r = <B><FONT COLOR="#A020F0">new</FONT></B> Node(mid, hi);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (mset != inf)
            l-&gt;set(lo,hi,mset), r-&gt;set(lo,hi,mset), mset = inf;
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (madd)
            l-&gt;add(lo,hi,madd), r-&gt;add(lo,hi,madd), madd = 0;
    }
};</PRE>
<HR>
<A NAME="file11">
<H1>code/LCA.cc 11/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Calculate power of two jumps in a tree,
 * to support fast upward jumps and LCAs.
 * Assumes the root node points to itself.
 * Time: construction $O(N \log N)$, queries $O(\log N)$
 * Status: Tested at Petrozavodsk, also stress-tested via LCA.cpp
 */</FONT></I>
 <I><FONT COLOR="#B22222">// Takes an array of parent pointers and returns
</FONT></I> <I><FONT COLOR="#B22222">// the LCA table.
</FONT></I>vector&lt;vi&gt; treeJump(vi&amp; P){
    <B><FONT COLOR="#228B22">int</FONT></B> on = 1, d = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B>(on &lt; sz(P)) on *= 2, d++;
    vector&lt;vi&gt; jmp(d, P);
    rep(i,1,d) rep(j,0,sz(P))
    jmp[i][j] = jmp[i-1][jmp[i-1][j]];
    <B><FONT COLOR="#A020F0">return</FONT></B> jmp;
}
<I><FONT COLOR="#B22222">// helper function to jump a certain number of parents
</FONT></I><I><FONT COLOR="#B22222">// up from a node in O(log(steps)) time.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">jmp</FONT></B>(vector&lt;vi&gt;&amp; tbl, <B><FONT COLOR="#228B22">int</FONT></B> nod, <B><FONT COLOR="#228B22">int</FONT></B> steps){
    rep(i,0,sz(tbl))
    <B><FONT COLOR="#A020F0">if</FONT></B>(steps&amp;(1&lt;&lt;i)) nod = tbl[i][nod];
    <B><FONT COLOR="#A020F0">return</FONT></B> nod;
}
<I><FONT COLOR="#B22222">// Find least common ancestor of two nodes.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lca</FONT></B>(vector&lt;vi&gt;&amp; tbl, vi&amp; depth, <B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (depth[a] &lt; depth[b]) swap(a, b);
    a = jmp(tbl, a, depth[a] - depth[b]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = sz(tbl); i--;) {
        <B><FONT COLOR="#228B22">int</FONT></B> c = tbl[i][a], d = tbl[i][b];
        <B><FONT COLOR="#A020F0">if</FONT></B> (c != d) a = c, b = d;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> tbl[0][a];
}</PRE>
<HR>
<A NAME="file12">
<H1>code/LiChao.cpp 12/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Li-Chao Tree. Store a family of functions with domain a subset of R
</FONT></I><I><FONT COLOR="#B22222">// where no two functions intersect
</FONT></I><I><FONT COLOR="#B22222">// more than once. Support querying for the max of all functions in the tree
</FONT></I><I><FONT COLOR="#B22222">// in O(log(n)) with O(log(n)) insertion
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> LiChao {
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ftype;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; params;
    <B><FONT COLOR="#228B22">int</FONT></B> maxn;

    vector&lt;params&gt; best_params;

    LiChao(<B><FONT COLOR="#228B22">int</FONT></B> maxN) {
        maxn = maxN;
        best_params = vector&lt;params&gt;(maxn * 4);
    }

    <I><FONT COLOR="#B22222">// The function you add to the tree. It is a family of functions
</FONT></I>    <I><FONT COLOR="#B22222">// parameterized by a
</FONT></I>    <I><FONT COLOR="#B22222">// Any two functions f(a, -), f(b, -) must intersect at most once,
</FONT></I>    <I><FONT COLOR="#B22222">// else the tree will not work.
</FONT></I>    ftype f(params a, ftype x) {
        <B><FONT COLOR="#A020F0">return</FONT></B> a.first * x + a.second;
    }

    <I><FONT COLOR="#B22222">// Add the function parameterized by nw to the tree
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> add_fn(params nw, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
        <B><FONT COLOR="#228B22">int</FONT></B> m = (l + r) / 2;
        <B><FONT COLOR="#228B22">bool</FONT></B> lef = f(nw, l) &lt; f(best_params[v], l);
        <B><FONT COLOR="#228B22">bool</FONT></B> mid = f(nw, m) &lt; f(best_params[v], m);
        <B><FONT COLOR="#A020F0">if</FONT></B> (mid) {
            swap(best_params[v], nw);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (r - l == 1) {
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (lef != mid) {
            add_fn(nw, 2 * v, l, m);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            add_fn(nw, 2 * v + 1, m, r);
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> add_fn(params nw) {
        <B><FONT COLOR="#A020F0">return</FONT></B> add_fn(nw, 1, 0, maxn);
    }

    <I><FONT COLOR="#B22222">// Compute the maximum valued function over all x
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
        <B><FONT COLOR="#228B22">int</FONT></B> m = (l + r) / 2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (r - l == 1) {
            <B><FONT COLOR="#A020F0">return</FONT></B> f(best_params[v], x);
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (x &lt; m) {
            <B><FONT COLOR="#A020F0">return</FONT></B> min(f(best_params[v], x), get(x, 2 * v, l, m));
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">return</FONT></B> min(f(best_params[v], x), get(x, 2 * v + 1, m, r));
        }
    }

    <B><FONT COLOR="#228B22">int</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">return</FONT></B> get(x, 1, 0, maxn);
    }
};

</PRE>
<HR>
<A NAME="file13">
<H1>code/Dinic.cc 13/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency list implementation of Dinic's blocking flow algorithm.
</FONT></I><I><FONT COLOR="#B22222">// This is very fast in practice, and only loses to push-relabel flow.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^2 |E|)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source and sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - maximum flow value
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain actual flow values, look at edges with capacity &gt; 0
</FONT></I><I><FONT COLOR="#B22222">//       (zero capacity edges are residual edges).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include&lt;cstdio&gt;
</FONT></B>
#<B><FONT COLOR="#5F9EA0">include&lt;vector&gt;
</FONT></B>
#<B><FONT COLOR="#5F9EA0">include&lt;queue&gt;
</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    LL cap, flow;
    Edge() {}
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, LL cap) : u(u), v(v), cap(cap), flow(0) {}
};

<B><FONT COLOR="#228B22">struct</FONT></B> Dinic {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;Edge&gt; E;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; g;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; d, pt;
    Dinic(<B><FONT COLOR="#228B22">int</FONT></B> N) : N(N), E(0), g(N), d(N), pt(N) {}
    <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, LL cap) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) {
            E.emplace_back(u, v, cap);
            g[u].emplace_back(E.size() - 1);
            E.emplace_back(v, u, 0);
            g[v].emplace_back(E.size() - 1);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> BFS(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
        queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q({S});
        fill(d.begin(), d.end(), N + 1);
        d[S] = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
            <B><FONT COLOR="#228B22">int</FONT></B> u = q.front();
            q.pop();
            <B><FONT COLOR="#A020F0">if</FONT></B> (u == T) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k: g[u]) {
                Edge &amp;e = E[k];
                <B><FONT COLOR="#A020F0">if</FONT></B> (e.flow &lt; e.cap &amp;&amp; d[e.v] &gt; d[e.u] + 1) {
                    d[e.v] = d[e.u] + 1;
                    q.emplace(e.v);
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> d[T] != N + 1;
    }
    LL DFS(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> T, LL flow = -1) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == T || flow == 0) <B><FONT COLOR="#A020F0">return</FONT></B> flow;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;i = pt[u]; i &lt; g[u].size(); ++i) {
            Edge &amp;e = E[g[u][i]];
            Edge &amp;oe = E[g[u][i] ^ 1];
            <B><FONT COLOR="#A020F0">if</FONT></B> (d[e.v] == d[e.u] + 1) {
                LL amt = e.cap - e.flow;
                <B><FONT COLOR="#A020F0">if</FONT></B> (flow != -1 &amp;&amp; amt &gt; flow) amt = flow;
                <B><FONT COLOR="#A020F0">if</FONT></B> (LL pushed = DFS(e.v, T, amt)) {
                    e.flow += pushed;
                    oe.flow -= pushed;
                    <B><FONT COLOR="#A020F0">return</FONT></B> pushed;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    LL MaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
        LL total = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (BFS(S, T)) {
            fill(pt.begin(), pt.end(), 0);
            <B><FONT COLOR="#A020F0">while</FONT></B> (LL flow = DFS(S, T))
                total += flow;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> total;
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves SPOJ problem #4110: Fast Maximum Flow (FASTFLOW)
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, E;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;N, &amp;E);
    Dinic dinic(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; E; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        LL cap;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%lld&quot;</FONT></B>, &amp;u, &amp;v, &amp;cap);
        dinic.AddEdge(u - 1, v - 1, cap);
        dinic.AddEdge(v - 1, u - 1, cap);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;%lld\n&quot;</FONT></B>, dinic.MaxFlow(0, N - 1));
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file14">
<H1>code/MinCostMaxFlow.cc 14/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Implementation of min cost max flow algorithm using adjacency
</FONT></I><I><FONT COLOR="#B22222">// matrix (Edmonds and Karp 1972).  This implementation keeps track of
</FONT></I><I><FONT COLOR="#B22222">// forward and reverse edges separately (so you can set cap[i][j] !=
</FONT></I><I><FONT COLOR="#B22222">// cap[j][i]).  For a regular max flow, set all edge costs to 0.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time, O(|V|^2) cost per augmentation
</FONT></I><I><FONT COLOR="#B22222">//     max flow:           O(|V|^3) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     min cost max flow:  O(|V|^4 * MAX_EDGE_COST) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (maximum flow value, minimum cost value)
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow, look at positive values only.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> L;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;L&gt; VL;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VL&gt; VVL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;
<B><FONT COLOR="#228B22">const</FONT></B> L INF = numeric_limits&lt;L&gt;::max() / 4;

<B><FONT COLOR="#228B22">struct</FONT></B> MinCostMaxFlow {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VVL cap, flow, cost;
    VI found;
    VL dist, pi, width;
    VPII dad;
    MinCostMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> N) :
            N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)),
            found(N), dist(N), pi(N), width(N), dad(N) {}
    <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, L cap, L cost) {
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cap[from][to] = cap;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cost[from][to] = cost;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> Relax(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> k, L cap, L cost, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
        L val = dist[s] + pi[s] - pi[k] + cost;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cap &amp;&amp; val &lt; dist[k]) {
            dist[k] = val;
            dad[k] = make_pair(s, dir);
            width[k] = min(cap, width[s]);
        }
    }
    L Dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        fill(found.begin(), found.end(), false);
        fill(dist.begin(), dist.end(), INF);
        fill(width.begin(), width.end(), 0);
        dist[s] = 0;
        width[s] = INF;

        <B><FONT COLOR="#A020F0">while</FONT></B> (s != -1) {
            <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
            found[s] = true;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (found[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
                Relax(s, k, flow[k][s], -cost[k][s], -1);
                <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
            }
            s = best;
        }

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++)
            pi[k] = min(pi[k] + dist[k], INF);
        <B><FONT COLOR="#A020F0">return</FONT></B> width[t];
    }
    pair&lt;L, L&gt; GetMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        L totflow = 0, totcost = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (L amt = Dijkstra(s, t)) {
            totflow += amt;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> x = t; x != s; x = dad[x].first) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (dad[x].second == 1) {
                    flow[dad[x].first][x] += amt;
                    totcost += amt * cost[dad[x].first][x];
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    flow[x][dad[x].first] -= amt;
                    totcost -= amt * cost[x][dad[x].first];
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(totflow, totcost);
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10594: Data Flow
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;

    <B><FONT COLOR="#A020F0">while</FONT></B> (scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;N, &amp;M) == 2) {
        VVL v(M, VL(3));
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++)
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld%Ld&quot;</FONT></B>, &amp;v[i][0], &amp;v[i][1], &amp;v[i][2]);
        L D, K;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld&quot;</FONT></B>, &amp;D, &amp;K);

        MinCostMaxFlow mcmf(N + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), K, v[i][2]);
            mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), K, v[i][2]);
        }
        mcmf.AddEdge(0, 1, D, 0);

        pair&lt;L, L&gt; res = mcmf.GetMaxFlow(0, N);

        <B><FONT COLOR="#A020F0">if</FONT></B> (res.first == D) {
            printf(<B><FONT COLOR="#BC8F8F">&quot;%Ld\n&quot;</FONT></B>, res.second);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            printf(<B><FONT COLOR="#BC8F8F">&quot;Impossible.\n&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file15">
<H1>code/MinCostMatching.cc 15/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Min cost bipartite matching via shortest augmenting paths
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// This is an O(n^3) implementation of a shortest augmenting path
</FONT></I><I><FONT COLOR="#B22222">// algorithm for finding min cost perfect matchings in dense
</FONT></I><I><FONT COLOR="#B22222">// graphs.  In practice, it solves 1000x1000 problems in around 1
</FONT></I><I><FONT COLOR="#B22222">// second.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   cost[i][j] = cost for pairing left node i with right node j
</FONT></I><I><FONT COLOR="#B22222">//   Lmate[i] = index of right node that left node i pairs with
</FONT></I><I><FONT COLOR="#B22222">//   Rmate[j] = index of left node that right node j pairs with
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The values in cost[i][j] may be positive or negative.  To perform
</FONT></I><I><FONT COLOR="#B22222">// maximization, simply negate the cost[][] matrix.
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; VD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VD&gt; VVD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">MinCostMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;cost, VI &amp;Lmate, VI &amp;Rmate) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = <B><FONT COLOR="#228B22">int</FONT></B>(cost.size());

    <I><FONT COLOR="#B22222">// construct dual feasible solution
</FONT></I>    VD u(n);
    VD v(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        u[i] = cost[i][0];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; n; j++) u[i] = min(u[i], cost[i][j]);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
        v[j] = cost[0][j] - u[0];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
    }

    <I><FONT COLOR="#B22222">// construct primal solution satisfying complementary slackness
</FONT></I>    Lmate = VI(n, -1);
    Rmate = VI(n, -1);
    <B><FONT COLOR="#228B22">int</FONT></B> mated = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] != -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(cost[i][j] - u[i] - v[j]) &lt; 1e-10) {
                Lmate[i] = j;
                Rmate[j] = i;
                mated++;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
    }

    VD dist(n);
    VI dad(n);
    VI seen(n);

    <I><FONT COLOR="#B22222">// repeat until primal solution is feasible
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> (mated &lt; n) {

        <I><FONT COLOR="#B22222">// find an unmatched left node
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> s = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (Lmate[s] != -1) s++;

        <I><FONT COLOR="#B22222">// initialize Dijkstra
</FONT></I>        fill(dad.begin(), dad.end(), -1);
        fill(seen.begin(), seen.end(), 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
            dist[k] = cost[s][k] - u[s] - v[k];

        <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (true) {

            <I><FONT COLOR="#B22222">// find closest
</FONT></I>            j = -1;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#A020F0">if</FONT></B> (j == -1 || dist[k] &lt; dist[j]) j = k;
            }
            seen[j] = 1;

            <I><FONT COLOR="#B22222">// termination condition
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;

            <I><FONT COLOR="#B22222">// relax neighbors
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[j];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> new_dist = dist[j] + cost[i][k] - u[i] - v[k];
                <B><FONT COLOR="#A020F0">if</FONT></B> (dist[k] &gt; new_dist) {
                    dist[k] = new_dist;
                    dad[k] = j;
                }
            }
        }

        <I><FONT COLOR="#B22222">// update dual variables
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == j || !seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[k];
            v[k] += dist[k] - dist[j];
            u[i] -= dist[k] - dist[j];
        }
        u[s] += dist[j];

        <I><FONT COLOR="#B22222">// augment along path
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B> (dad[j] &gt;= 0) {
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> d = dad[j];
            Rmate[j] = Rmate[d];
            Lmate[Rmate[j]] = j;
            j = d;
        }
        Rmate[j] = s;
        Lmate[s] = j;

        mated++;
    }

    <B><FONT COLOR="#228B22">double</FONT></B> value = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        value += cost[i][Lmate[i]];

    <B><FONT COLOR="#A020F0">return</FONT></B> value;
}
</PRE>
<HR>
<A NAME="file16">
<H1>code/MaxBipartiteMatching.cc 16/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This code performs maximum bipartite matching.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|E| |V|) -- often much faster in practice
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: w[i][j] = edge between row node i and column node j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//           mc[j] = assignment for column node j, -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//           function returns number of matches made
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">FindMatch</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc, VI &amp;seen) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; w[i].size(); j++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] &amp;&amp; !seen[j]) {
            seen[j] = true;
            <B><FONT COLOR="#A020F0">if</FONT></B> (mc[j] &lt; 0 || FindMatch(mc[j], w, mr, mc, seen)) {
                mr[i] = j;
                mc[j] = i;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">BipartiteMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc) {
    mr = VI(w.size(), -1);
    mc = VI(w[0].size(), -1);
    <B><FONT COLOR="#228B22">int</FONT></B> ct = 0;
    <I><FONT COLOR="#B22222">// OPTIONAL SECTION: Find a greedy matching (improves performance by a big constant)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; w.size(); ++i) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; w[0].size(); ++j) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] &amp;&amp; mc[j] == -1) {
                mc[j] = i;
                mr[i] = j;
                ct++;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
    }
    <I><FONT COLOR="#B22222">// END OPTIONAL SECTION
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; w.size(); i++) {
        VI seen(w[0].size());
        <B><FONT COLOR="#A020F0">if</FONT></B> (mr[i] == -1 &amp;&amp; FindMatch(i, w, mr, mc, seen)) ct++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ct;
}
</PRE>
<HR>
<A NAME="file17">
<H1>code/MinCut.cc 17/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (min cut value, nodes in half of min cut)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;
pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; GetMinCut(VVI &amp;weights) {
    <B><FONT COLOR="#228B22">int</FONT></B> N = weights.size();
    VI used(N), cut, best_cut;
    <B><FONT COLOR="#228B22">int</FONT></B> best_weight = -1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> phase = N - 1; phase &gt;= 0; phase--) {
        VI w = weights[0];
        VI added = used;
        <B><FONT COLOR="#228B22">int</FONT></B> prev, last = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; phase; i++) {
            prev = last;
            last = -1;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; N; j++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == phase - 1) {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
                used[last] = true;
                cut.push_back(last);
                <B><FONT COLOR="#A020F0">if</FONT></B> (best_weight == -1 || w[last] &lt; best_weight) {
                    best_cut = cut;
                    best_weight = w[last];
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                    w[j] += weights[last][j];
                added[last] = true;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(best_weight, best_cut);
}
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10989: Bomb, Divide and Conquer
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    cin &gt;&gt; N;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> n, m;
        cin &gt;&gt; n &gt;&gt; m;
        VVI weights(n, VI(n));
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) {
            <B><FONT COLOR="#228B22">int</FONT></B> a, b, c;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            weights[a - 1][b - 1] = weights[b - 1][a - 1] = c;
        }
        pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; res = GetMinCut(weights);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Case #&quot;</FONT></B> &lt;&lt; i + 1 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; res.first &lt;&lt; endl;
    }
}
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file18">
<H1>code/Geometry.py 18/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<B><FONT COLOR="#A020F0">from</FONT></B> collections <B><FONT COLOR="#A020F0">import</FONT></B> namedtuple
<B><FONT COLOR="#A020F0">import</FONT></B> math

<B><FONT COLOR="#A020F0">class</FONT></B> Point(namedtuple(<B><FONT COLOR="#BC8F8F">&quot;_Point&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;x y&quot;</FONT></B>)):
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__add__</FONT></B>(self, other):
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(self.x + other.x, self.y + other.y)
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__sub__</FONT></B>(self, other):
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(self.x - other.x, self.y - other.y)
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__mul__</FONT></B>(self, scalar):
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(scalar * self.x, scalar * self.y)
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">__truediv__</FONT></B>(self, scalar):
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(self.x / scalar, self.y / scalar)
    __rmul__ = __mul__
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">dist2</FONT></B>(self):
        <B><FONT COLOR="#A020F0">return</FONT></B> self.x**2 + self.y**2
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">dist</FONT></B>(self):
        <B><FONT COLOR="#A020F0">return</FONT></B> math.sqrt(self.dist2())
    __abs__ = dist
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">theta</FONT></B>(self):
        <B><FONT COLOR="#A020F0">return</FONT></B> math.atan2(self.y, self.x)
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(self, other):
        <B><FONT COLOR="#A020F0">return</FONT></B> self.x*other.x + self.y*other.y
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(self, other):
        <B><FONT COLOR="#A020F0">return</FONT></B> self.x*other.y - self.y * other.x
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">unit</FONT></B>(self):
        <B><FONT COLOR="#A020F0">return</FONT></B> (1/abs(self)) * self
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">rotate</FONT></B>(self, theta):
        cos_t = math.cos(theta)
        sin_t = math.sin(theta)
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(self.x*cos_t - self.y*sin_t,
                     self.x*sin_t + self.y*cos_t)
    <B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">perp</FONT></B>(self):
        <B><FONT COLOR="#A020F0">return</FONT></B> Point(-self.y, self.x)

<B><FONT COLOR="#A020F0">class</FONT></B> Circle(namedtuple(<B><FONT COLOR="#BC8F8F">&quot;_Circle&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;center radius&quot;</FONT></B>)):
    <B><FONT COLOR="#A020F0">pass</FONT></B>

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">circle_circle_intersect</FONT></B>(circle1, circle2):
    a, r1 = circle1
    b, r2 = circle2
    <B><FONT COLOR="#A020F0">if</FONT></B> (a == b):
        <B><FONT COLOR="#A020F0">if</FONT></B> r1 == r2:
            <B><FONT COLOR="#A020F0">raise</FONT></B> ValueError
        <B><FONT COLOR="#A020F0">return</FONT></B> []
    vec = b - a
    d2 = vec.dist2()
    sum = r1 + r2
    dif = r1 - r2
    p = (d2 + r1 * r1 - r2 * r2) / (d2 * 2)
    h2 = r1 * r1 - p * p * d2
    <B><FONT COLOR="#A020F0">if</FONT></B> sum * sum &lt; d2 <B><FONT COLOR="#A020F0">or</FONT></B> dif * dif &gt; d2:
        <B><FONT COLOR="#A020F0">return</FONT></B> []
    mid = a + vec * p
    per = vec.perp() * math.sqrt(max(0, h2) / d2)
    <B><FONT COLOR="#A020F0">return</FONT></B> [mid + per, mid - per]


<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">circle_tangents</FONT></B>(circle1, circle2):
    <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;
    Get 0, 1, or 2 outer tangents as a list of pairs of points.
    Negate r2 to get the inner tangents.
    &quot;&quot;&quot;</FONT></B>
    c1, r1 = circle1
    c2, r2 = circle2
    d = c2 - c1
    dr = r1 - r2
    d2 = d.dist2()
    h2 = d2 - dr * dr
    <B><FONT COLOR="#A020F0">if</FONT></B> d2 == 0 <B><FONT COLOR="#A020F0">or</FONT></B> h2 &lt; 0:
        <B><FONT COLOR="#A020F0">return</FONT></B> []
    out = []
    <B><FONT COLOR="#A020F0">for</FONT></B> sign <B><FONT COLOR="#A020F0">in</FONT></B> (-1, 1):
        v = (d * dr + d.perp() * math.sqrt(h2) * sign) / d2
        pair = (c1 + v * r1,
                c2 + v * r2)
        out.append(pair)
    <B><FONT COLOR="#A020F0">if</FONT></B> h2 == 0:
        out.pop()
    <B><FONT COLOR="#A020F0">return</FONT></B> out


<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">circle_line_intersect</FONT></B>(circle, a, b):
    <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;a and b are endpoints&quot;&quot;&quot;</FONT></B>
    <B><FONT COLOR="#A020F0">assert</FONT></B> isinstance(a, Point) <B><FONT COLOR="#A020F0">and</FONT></B> isinstance(b, Point)
    c, r = circle
    ab = b - a
    p = a + ab * (c - a).dot(ab) / ab.dist2()
    s = Point.cross(b-a, c-a)
    h2 = r*r - s * s / ab.dist2()
    <B><FONT COLOR="#A020F0">if</FONT></B> h2 &lt; 0:
        <B><FONT COLOR="#A020F0">return</FONT></B> ()
    <B><FONT COLOR="#A020F0">if</FONT></B> h2 == 0:
        <B><FONT COLOR="#A020F0">return</FONT></B> (p,)
    h = ab.unit() * math.sqrt(h2)
    <B><FONT COLOR="#A020F0">return</FONT></B> (p - h, p + h)

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">segment_intersection</FONT></B>(seg1, seg2):
    a, b = seg1
    c, d = seg2
    oa = Point.cross(d-c, a-c)
    ob = Point.cross(d-c, b-c)
    oc = Point.cross(b-a, c-a)
    od = Point.cross(b-a, d-a)
    <B><FONT COLOR="#A020F0">if</FONT></B> on_segment(*seg1, c):
        <B><FONT COLOR="#A020F0">return</FONT></B> c
    <B><FONT COLOR="#A020F0">if</FONT></B> on_segment(*seg1, d):
        <B><FONT COLOR="#A020F0">return</FONT></B> d
    <B><FONT COLOR="#A020F0">if</FONT></B> on_segment(*seg2, a):
        <B><FONT COLOR="#A020F0">return</FONT></B> a
    <B><FONT COLOR="#A020F0">if</FONT></B> on_segment(*seg2, b):
        <B><FONT COLOR="#A020F0">return</FONT></B> b
    <B><FONT COLOR="#A020F0">if</FONT></B> oa * ob &lt; 0 <B><FONT COLOR="#A020F0">and</FONT></B> oc * od &lt; 0:
        <B><FONT COLOR="#A020F0">return</FONT></B> (a * ob - b * oa) / (ob - oa)
    <B><FONT COLOR="#A020F0">return</FONT></B> None
    <I><FONT COLOR="#B22222"># set &lt; P &gt; s;
</FONT></I>    <I><FONT COLOR="#B22222"># if (onSegment(c, d, a)) s.insert(a);
</FONT></I>    <I><FONT COLOR="#B22222"># if (onSegment(c, d, b)) s.insert(b);
</FONT></I>    <I><FONT COLOR="#B22222"># if (onSegment(a, b, c)) s.insert(c);
</FONT></I>    <I><FONT COLOR="#B22222"># if (onSegment(a, b, d)) s.insert(d);
</FONT></I>    <I><FONT COLOR="#B22222"># return {all(s)};
</FONT></I>

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">on_segment</FONT></B>(start, end, x):
    u = start - x
    v = end - x
    <B><FONT COLOR="#A020F0">return</FONT></B> u.cross(v) == 0 <B><FONT COLOR="#A020F0">and</FONT></B> u.dot(v) &lt;= 0

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">distance_to_segment</FONT></B>(start, end, x):
    <B><FONT COLOR="#A020F0">if</FONT></B> start == end:
        <B><FONT COLOR="#A020F0">return</FONT></B> (start-x).dist()
    d = (end-start).dist2()
    t = min(d, max(0, (x-start).dot(end-start)))
    <B><FONT COLOR="#A020F0">return</FONT></B> abs( (x-start)*d - (end-start)*t ) / d

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">in_polygon</FONT></B>(poly, point):
    <B><FONT COLOR="#BC8F8F">&quot;&quot;&quot;poly is a list of points&quot;&quot;&quot;</FONT></B>
    wind = 0
    <B><FONT COLOR="#A020F0">for</FONT></B> i, p <B><FONT COLOR="#A020F0">in</FONT></B> enumerate(poly):
        q = poly[(i + 1) % len(poly)]
        <I><FONT COLOR="#B22222"># maybe handle on_segment here
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> p.y &lt;= point.y:
            <B><FONT COLOR="#A020F0">if</FONT></B> q.y &gt; point.y:
                <I><FONT COLOR="#B22222"># upward crossing
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> turnLeft(p, q, point):
                    wind += 1
        <B><FONT COLOR="#A020F0">else</FONT></B>:
            <B><FONT COLOR="#A020F0">if</FONT></B> q.y &lt;= point.y:
                <B><FONT COLOR="#A020F0">if</FONT></B> turnLeft(q, p, point):
                    wind -= 1
    <B><FONT COLOR="#A020F0">return</FONT></B> wind


<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">turnLeft</FONT></B>(p0, p1, p2):
    <I><FONT COLOR="#B22222"># Are the points counterclockwise-oriented?
</FONT></I>    u = p1 - p0
    v = p2 - p1
    <B><FONT COLOR="#A020F0">return</FONT></B> u.cross(v) &gt;= 0


<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">hull_one_side</FONT></B>(points):
    hull = []
    <B><FONT COLOR="#A020F0">for</FONT></B> point <B><FONT COLOR="#A020F0">in</FONT></B> points:
        <B><FONT COLOR="#A020F0">while</FONT></B> len(hull) &gt;= 2 <B><FONT COLOR="#A020F0">and</FONT></B> turnLeft(hull[-2], hull[-1], point):
            hull.pop()
        hull.append(point)
    <B><FONT COLOR="#A020F0">return</FONT></B> hull

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">convex_hull</FONT></B>(points):
    <B><FONT COLOR="#A020F0">if</FONT></B> len(points) &lt;= 1:
        <B><FONT COLOR="#A020F0">return</FONT></B> points
    points = sorted(points)
    h1 = hull_one_side(points)
    points.reverse()
    h1.pop()
    h2 = hull_one_side(points)
    h2.pop()
    h1.extend(h2)
    <B><FONT COLOR="#A020F0">return</FONT></B> h1

<B><FONT COLOR="#A020F0">def</FONT></B> <B><FONT COLOR="#0000FF">shoelace</FONT></B>(points):
    <B><FONT COLOR="#A020F0">return</FONT></B> sum(points[i-1].cross(points[i])
               <B><FONT COLOR="#A020F0">for</FONT></B> i <B><FONT COLOR="#A020F0">in</FONT></B> range(len(points))) / 2
</PRE>
<HR>
<A NAME="file19">
<H1>code/Geom3D.java 19/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> Geom3D {
  <I><FONT COLOR="#B22222">// distance from point (x, y, z) to plane aX + bY + cZ + d = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptPlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> x, <B><FONT COLOR="#A020F0">double</FONT></B> y, <B><FONT COLOR="#A020F0">double</FONT></B> z,
      <B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c, <B><FONT COLOR="#A020F0">double</FONT></B> d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(a*x + b*y + c*z + d) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance between parallel planes aX + bY + cZ + d1 = 0 and
</FONT></I>  <I><FONT COLOR="#B22222">// aX + bY + cZ + d2 = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> planePlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c,
      <B><FONT COLOR="#A020F0">double</FONT></B> d1, <B><FONT COLOR="#A020F0">double</FONT></B> d2) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(d1 - d2) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance from point (px, py, pz) to line (x1, y1, z1)-(x2, y2, z2)
</FONT></I>  <I><FONT COLOR="#B22222">// (or ray, or segment; in the case of the ray, the endpoint is the
</FONT></I>  <I><FONT COLOR="#B22222">// first point)
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> LINE = 0;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> SEGMENT = 1;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> RAY = 2;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDistSq(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">double</FONT></B> pd2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);
    
    <B><FONT COLOR="#A020F0">double</FONT></B> x, y, z;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pd2 == 0) {
      x = x1;
      y = y1;
      z = z1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">double</FONT></B> u = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1) + (pz-z1)*(z2-z1)) / pd2;
      x = x1 + u * (x2 - x1);
      y = y1 + u * (y2 - y1);
      z = z1 + u * (z2 - z1);
      <B><FONT COLOR="#A020F0">if</FONT></B> (type != LINE &amp;&amp; u &lt; 0) {
        x = x1;
        y = y1;
        z = z1;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (type == SEGMENT &amp;&amp; u &gt; 1.0) {
        x = x2;
        y = y2;
        z = z2;
      }
    }
    
    <B><FONT COLOR="#A020F0">return</FONT></B> (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz);
  }
  
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDist(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.sqrt(ptLineDistSq(x1, y1, z1, x2, y2, z2, px, py, pz, type));
  }
}
</PRE>
<HR>
<A NAME="file20">
<H1>code/Delaunay.cc 20/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Slow but simple Delaunay triangulation. Does not handle
</FONT></I><I><FONT COLOR="#B22222">// degenerate cases (from O'Rourke, Computational Geometry in C)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^4)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    x[] = x-coordinates
</FONT></I><I><FONT COLOR="#B22222">//           y[] = y-coordinates
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   triples = a vector containing m triples of indices
</FONT></I><I><FONT COLOR="#B22222">//                     corresponding to triangle vertices
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include&lt;vector&gt;
</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;

<B><FONT COLOR="#228B22">struct</FONT></B> triple {
    <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;
    triple() {}
    triple(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">int</FONT></B> k) : i(i), j(j), k(k) {}
};

vector&lt;triple&gt; delaunayTriangulation(vector&lt;T&gt; &amp;x, vector&lt;T&gt; &amp;y) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = x.size();
    vector&lt;T&gt; z(n);
    vector&lt;triple&gt; ret;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        z[i] = x[i] * x[i] + y[i] * y[i];

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n - 2; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; n; j++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i + 1; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#228B22">double</FONT></B> xn = (y[j] - y[i]) * (z[k] - z[i]) - (y[k] - y[i]) * (z[j] - z[i]);
                <B><FONT COLOR="#228B22">double</FONT></B> yn = (x[k] - x[i]) * (z[j] - z[i]) - (x[j] - x[i]) * (z[k] - z[i]);
                <B><FONT COLOR="#228B22">double</FONT></B> zn = (x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]);
                <B><FONT COLOR="#228B22">bool</FONT></B> flag = zn &lt; 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m = 0; flag &amp;&amp; m &lt; n; m++)
                    flag = flag &amp;&amp; ((x[m] - x[i]) * xn +
                                    (y[m] - y[i]) * yn +
                                    (z[m] - z[i]) * zn &lt;= 0);
                <B><FONT COLOR="#A020F0">if</FONT></B> (flag) ret.push_back(triple(i, j, k));
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    T xs[] = {0, 0, 1, 0.9};
    T ys[] = {0, 1, 0, 0.9};
    vector&lt;T&gt; x(&amp;xs[0], &amp;xs[4]), y(&amp;ys[0], &amp;ys[4]);
    vector&lt;triple&gt; tri = delaunayTriangulation(x, y);

    <I><FONT COLOR="#B22222">//expected: 0 1 3
</FONT></I>    <I><FONT COLOR="#B22222">//          0 3 2
</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; tri.size(); i++)
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d\n&quot;</FONT></B>, tri[i].i, tri[i].j, tri[i].k);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file21">
<H1>code/Euclid.cc 21/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This is a collection of useful code for solving problems that
</FONT></I><I><FONT COLOR="#B22222">// involve modular linear equations.  Note that all of the
</FONT></I><I><FONT COLOR="#B22222">// algorithms described here work on nonnegative integers.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((a % b) + b) % b;
}
<I><FONT COLOR="#B22222">// computes gcd(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">gcd</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        <B><FONT COLOR="#228B22">int</FONT></B> t = a % b;
        a = b;
        b = t;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}
<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lcm</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a, b) * b;
}
<I><FONT COLOR="#B22222">// (a^b) mod m via successive squaring
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">powermod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#228B22">int</FONT></B> ret = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (b &amp; 1) ret = mod(ret * a, m);
        a = mod(a * a, m);
        b &gt;&gt;= 1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// Finds two integers $x$ and $y$, such that $ax+by=\gcd(a,b)$. If
</FONT></I><I><FONT COLOR="#B22222">// If $a$ and $b$ are coprime, then $x$ is the inverse of $a \pmod{b}$.
</FONT></I><I><FONT COLOR="#B22222">// Returns gcd(a, b)
</FONT></I>ll <B><FONT COLOR="#0000FF">extended_euclid</FONT></B>(ll a, ll b, ll &amp;x, ll &amp;y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!b) <B><FONT COLOR="#A020F0">return</FONT></B> x = 1, y = 0, a;
    ll d = euclid(b, a % b, y, x);
    <B><FONT COLOR="#A020F0">return</FONT></B> y -= a/b * x, d;
}
<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I>VI <B><FONT COLOR="#0000FF">modular_linear_equation_solver</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    VI ret;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(b % g)) {
        x = mod(x * (b / g), n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; g; i++)
            ret.push_back(mod(x + i * (n / g), n));
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod_inverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (g &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#A020F0">return</FONT></B> mod(x, n);
}
<I><FONT COLOR="#B22222">// compute mod inverse of all numbers up to n
</FONT></I>vector&lt;ll&gt; precompute_inv_mod(<B><FONT COLOR="#228B22">int</FONT></B> n, ll mod) {
    vector&lt;ll&gt; inv(n + 1);
    inv[1] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; ++i) {
        inv[i] = mod - (mod / i) * inv[mod % i] % mod;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> inv;
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m1 = r1, z % m2 = r2.  Here, z is unique modulo M = lcm(m1, m2).
</FONT></I><I><FONT COLOR="#B22222">// Return (z, M).  On failure, M = -1.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> m1, <B><FONT COLOR="#228B22">int</FONT></B> r1, <B><FONT COLOR="#228B22">int</FONT></B> m2, <B><FONT COLOR="#228B22">int</FONT></B> r2) {
    <B><FONT COLOR="#228B22">int</FONT></B> s, t;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(m1, m2, s, t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (r1 % g != r2 % g) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s * r2 * m1 + t * r1 * m2, m1 * m2) / g, m1 * m2 / g);
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m[i] = r[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (m[i]).  Return (z, M). On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1. Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;m, <B><FONT COLOR="#228B22">const</FONT></B> VI &amp;r) {
    PII ret = make_pair(r[0], m[0]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m.size(); i++) {
        ret = chinese_remainder_theorem(ret.second, ret.first, m[i], r[i]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c
</FONT></I><I><FONT COLOR="#B22222">// returns whether the solution exists
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> c, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!a &amp;&amp; !b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = 0; y = 0;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!a) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c % b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = 0; y = c / b;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c % a) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = c / a; y = 0;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> g = gcd(a, b);
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % g) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    x = c / g * mod_inverse(a / g, b / g);
    y = (c - a * x) / b;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(14, 30, x, y);
    cout &lt;&lt; g &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; y &lt;&lt; endl; <I><FONT COLOR="#B22222">//2 -2 1
</FONT></I>    VI sols = modular_linear_equation_solver(14, 30, 100);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sols.size(); i++) cout &lt;&lt; sols[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; <I><FONT COLOR="#B22222">// 95 451
</FONT></I>    cout &lt;&lt; endl;
    cout &lt;&lt; mod_inverse(8, 9) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 8
</FONT></I>    PII ret = chinese_remainder_theorem(VI({3, 5, 7}), VI({2, 3, 2}));
    cout &lt;&lt; ret.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; ret.second &lt;&lt; endl; <I><FONT COLOR="#B22222">// 23 105
</FONT></I>    ret = chinese_remainder_theorem(VI({4, 6}), VI({3, 5}));
    cout &lt;&lt; ret.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; ret.second &lt;&lt; endl; <I><FONT COLOR="#B22222">// 11 12
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!linear_diophantine(7, 2, 5, x, y)) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;ERROR&quot;</FONT></B> &lt;&lt; endl;
    cout &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; y &lt;&lt; endl; <I><FONT COLOR="#B22222">// 5 -15
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file22">
<H1>code/Modular.cpp 22/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">int</FONT></B> MOD=998'244'353&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> Modular {
    <B><FONT COLOR="#228B22">int</FONT></B> value;
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MOD_value = MOD;

    Modular(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> v = 0) { value = v % MOD; <B><FONT COLOR="#A020F0">if</FONT></B> (value &lt; 0) value += MOD;}
    Modular(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> b) : value(0){ *<B><FONT COLOR="#A020F0">this</FONT></B> += a; *<B><FONT COLOR="#A020F0">this</FONT></B> /= b;}

    Modular&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>+=(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) {value += b.value; <B><FONT COLOR="#A020F0">if</FONT></B> (value &gt;= MOD) value -= MOD; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
    Modular&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>-=(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) {value -= b.value; <B><FONT COLOR="#A020F0">if</FONT></B> (value &lt; 0) value += MOD;<B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
    Modular&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>*=(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) {value = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>)value * b.value % MOD;<B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}

    <B><FONT COLOR="#228B22">friend</FONT></B> Modular mexp(Modular a, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> e) {
        Modular res = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (e) { <B><FONT COLOR="#A020F0">if</FONT></B> (e&amp;1) res *= a; a *= a; e &gt;&gt;= 1; }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular inverse(Modular a) { <B><FONT COLOR="#A020F0">return</FONT></B> mexp(a, MOD - 2); }

    Modular&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>/=(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) { <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B> *= inverse(b); }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular <B><FONT COLOR="#A020F0">operator</FONT></B>+(Modular a, Modular <B><FONT COLOR="#228B22">const</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> a += b; }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular <B><FONT COLOR="#A020F0">operator</FONT></B>-(Modular a, Modular <B><FONT COLOR="#228B22">const</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> a -= b; }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular <B><FONT COLOR="#A020F0">operator</FONT></B>-(Modular <B><FONT COLOR="#228B22">const</FONT></B> a) { <B><FONT COLOR="#A020F0">return</FONT></B> 0 - a; }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular <B><FONT COLOR="#A020F0">operator</FONT></B>*(Modular a, Modular <B><FONT COLOR="#228B22">const</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> a *= b; }
    <B><FONT COLOR="#228B22">friend</FONT></B> Modular <B><FONT COLOR="#A020F0">operator</FONT></B>/(Modular a, Modular <B><FONT COLOR="#228B22">const</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> a /= b; }
    <B><FONT COLOR="#228B22">friend</FONT></B> std::ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream&amp; os, Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; a) {<B><FONT COLOR="#A020F0">return</FONT></B> os &lt;&lt; a.value;}
    <B><FONT COLOR="#228B22">friend</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; a, Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) {<B><FONT COLOR="#A020F0">return</FONT></B> a.value == b.value;}
    <B><FONT COLOR="#228B22">friend</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>!=(Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; a, Modular <B><FONT COLOR="#228B22">const</FONT></B>&amp; b) {<B><FONT COLOR="#A020F0">return</FONT></B> a.value != b.value;}
};
<I><FONT COLOR="#B22222">// Chained Multiplication or Successive Simple Multiplication
</FONT></I>Modular&lt;998244353&gt; a=1, m=123456789;
a *= m * m * m; <I><FONT COLOR="#B22222">// a = 519994069
</FONT></I><I><FONT COLOR="#B22222">// Inverse
</FONT></I>a=inverse(m) <I><FONT COLOR="#B22222">// a=25170271
</FONT></I><I><FONT COLOR="#B22222">// fractions
</FONT></I>Modular&lt;&gt; frac=(1,2); <I><FONT COLOR="#B22222">// frac=1*2^(-1) % 998244353 = 499122177
</FONT></I><I><FONT COLOR="#B22222">// Modular exponentiation
</FONT></I>Modular&lt;&gt; power(2);
power=mexp(power,500); <I><FONT COLOR="#B22222">// power = 616118644</FONT></I></PRE>
<HR>
<A NAME="file23">
<H1>code/GaussJordan.cc 23/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
T GaussJordan(VVT &amp;a, VVT &amp;b) {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
    VI irow(n), icol(n), ipiv(n);
    T det = 1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
                        <B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) {
                            pj = j;
                            pk = k;
                        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) {
            cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl;
            exit(0);
        }
        ipiv[pk]++;
        swap(a[pj], a[pk]);
        swap(b[pj], b[pk]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
        irow[i] = pj;
        icol[i] = pk;

        T c = 1.0 / a[pk][pk];
        det *= a[pk][pk];
        a[pk][pk] = 1.0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
                c = a[p][pk];
                a[p][pk] = 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;
            }
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n - 1; p &gt;= 0; p--)
        <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
        }

    <B><FONT COLOR="#A020F0">return</FONT></B> det;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = {{1, 2, 3, 4},
                      {1, 0, 1, 0},
                      {5, 3, 2, 4},
                      {6, 1, 4, 6}};
    <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = {{1, 2},
                      {4, 3},
                      {5, 6},
                      {8, 7}};
    VVT a(n), b(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        a[i] = VT(A[i], A[i] + n);
        b[i] = VT(B[i], B[i] + m);
    }

    <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);

    <I><FONT COLOR="#B22222">// expected: 60
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>    <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }

    <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>    <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>    <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>    <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file24">
<H1>code/ReducedRowEchelonForm.cc 24/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Reduced row echelon form via Gauss-Jordan elimination 
</FONT></I><I><FONT COLOR="#B22222">// with partial pivoting.  This can be used for computing
</FONT></I><I><FONT COLOR="#B22222">// the rank of a matrix.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   rref[][] = an nxm matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns rank of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPSILON = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">rref</FONT></B>(VVT &amp;a) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">int</FONT></B> m = a[0].size();
    <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; m &amp;&amp; r &lt; n; c++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = r;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = r + 1; i &lt; n; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[i][c]) &gt; fabs(a[j][c])) j = i;
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[j][c]) &lt; EPSILON) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        swap(a[j], a[r]);

        T s = 1.0 / a[r][c];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[r][j] *= s;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) {
                T t = a[i][c];
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[i][j] -= t * a[r][j];
            }
        r++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> r;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 5, m = 4;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][m] = {
            {16, 2,  3,  13},
            {5,  11, 10, 8},
            {9,  7,  6,  12},
            {4,  14, 15, 1},
            {13, 21, 21, 13}};
    VVT a(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        a[i] = VT(A[i], A[i] + m);

    <B><FONT COLOR="#228B22">int</FONT></B> rank = rref(a);

    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Rank: &quot;</FONT></B> &lt;&lt; rank &lt;&lt; endl; <I><FONT COLOR="#B22222">// 3
</FONT></I>
    <I><FONT COLOR="#B22222">// expected: 1 0 0 1
</FONT></I>    <I><FONT COLOR="#B22222">//           0 1 0 3
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 1 -3
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 0 3.10862e-15
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 0 2.22045e-15
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;rref: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 4; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file25">
<H1>code/FFT_new.cc 25/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

<B><FONT COLOR="#228B22">struct</FONT></B> cpx {
    cpx() {}
    cpx(<B><FONT COLOR="#228B22">double</FONT></B> aa) : a(aa), b(0) {}
    cpx(<B><FONT COLOR="#228B22">double</FONT></B> aa, <B><FONT COLOR="#228B22">double</FONT></B> bb) : a(aa), b(bb) {}
    <B><FONT COLOR="#228B22">double</FONT></B> a, b;
    <B><FONT COLOR="#228B22">double</FONT></B> modsq(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> a * a + b * b;
    }
    cpx bar(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a, -b);
    }
};

cpx <B><FONT COLOR="#A020F0">operator</FONT></B>+(cpx a, cpx b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a.a + b.a, a.b + b.b);
}
cpx <B><FONT COLOR="#A020F0">operator</FONT></B>*(cpx a, cpx b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);
}
cpx <B><FONT COLOR="#A020F0">operator</FONT></B>/(cpx a, cpx b) {
    cpx r = a * b.bar();
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(r.a / b.modsq(), r.b / b.modsq());
}
cpx <B><FONT COLOR="#0000FF">EXP</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> theta) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(cos(theta), sin(theta));
}
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> two_pi = 4 * acos(0);
<I><FONT COLOR="#B22222">// in:     input array
</FONT></I><I><FONT COLOR="#B22222">// out:    output array
</FONT></I><I><FONT COLOR="#B22222">// step:   {SET TO 1} (used internally)
</FONT></I><I><FONT COLOR="#B22222">// size:   length of the input/output {MUST BE A POWER OF 2}
</FONT></I><I><FONT COLOR="#B22222">// dir:    either plus or minus one (direction of the FFT, 1 is first)
</FONT></I><I><FONT COLOR="#B22222">// RESULT: out[k] = \sum_{j=0}^{size - 1} in[j] * exp(dir * 2pi * i * j * k / size)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">FFT</FONT></B>(cpx *in, cpx *out, <B><FONT COLOR="#228B22">int</FONT></B> step, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (size &lt; 1) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (size == 1) {
        out[0] = in[0];
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    FFT(in, out, step * 2, size / 2, dir);
    FFT(in + step, out + size / 2, step * 2, size / 2, dir);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; size / 2; i++) {
        cpx even = out[i];
        cpx odd = out[i + size / 2];
        out[i] = even + EXP(dir * two_pi * i / size) * odd;
        out[i + size / 2] = even + EXP(dir * two_pi * (i + size / 2) / size) * odd;
    }
}

<I><FONT COLOR="#B22222">// Usage:
</FONT></I><I><FONT COLOR="#B22222">// f[0...N-1] and g[0..N-1] are numbers
</FONT></I><I><FONT COLOR="#B22222">// Want to compute the convolution h, defined by
</FONT></I><I><FONT COLOR="#B22222">// h[n] = sum of f[k]g[n-k] (k = 0, ..., N-1).
</FONT></I><I><FONT COLOR="#B22222">// Here, the index is cyclic; f[-1] = f[N-1], f[-2] = f[N-2], etc.
</FONT></I><I><FONT COLOR="#B22222">// Let F[0...N-1] be FFT(f), and similarly, define G and H.
</FONT></I><I><FONT COLOR="#B22222">// The convolution theorem says H[n] = F[n]G[n] (element-wise product).
</FONT></I><I><FONT COLOR="#B22222">// To compute h[] in O(N log N) time, do the following:
</FONT></I><I><FONT COLOR="#B22222">//   1. Compute F and G (pass dir = 1 as the argument).
</FONT></I><I><FONT COLOR="#B22222">//   2. Get H by element-wise multiplying F and G.
</FONT></I><I><FONT COLOR="#B22222">//   3. Get h by taking the inverse FFT (use dir = -1 as the argument)
</FONT></I><I><FONT COLOR="#B22222">//      and *dividing by N*. DO NOT FORGET THIS SCALING FACTOR.
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
    printf(<B><FONT COLOR="#BC8F8F">&quot;If rows come in identical pairs, then everything works.\n&quot;</FONT></B>);

    cpx a[8] = {0, 1, cpx(1, 3), cpx(0, 5), 1, 0, 2, 0};
    cpx b[8] = {1, cpx(0, -2), cpx(0, 1), 3, -1, -3, 1, -2};
    cpx A[8];
    cpx B[8];
    FFT(a, A, 1, 8, 1);
    FFT(b, B, 1, 8, 1);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, A[i].a, A[i].b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        cpx Ai(0, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 8; j++) {
            Ai = Ai + a[j] * EXP(j * i * two_pi / 8);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, Ai.a, Ai.b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);

    cpx AB[8];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++)
        AB[i] = A[i] * B[i];
    cpx aconvb[8];
    FFT(AB, aconvb, 1, 8, -1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++)
        aconvb[i] = aconvb[i] / 8;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, aconvb[i].a, aconvb[i].b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        cpx aconvbi(0, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 8; j++) {
            aconvbi = aconvbi + a[j] * b[(8 + i - j) % 8];
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, aconvbi.a, aconvbi.b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

</PRE>
<HR>
<A NAME="file26">
<H1>code/CalculatePhi.cpp 26/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: Hakan Terelius
 * Date: 2009-09-25
 * License: CC0
 * Description: Precompute the number of positive integers coprime to N up to a given limit.
 * - The sum phi(d) for all divisors d of n is equal to n.
 * - The sum of all positive numbers less than n that are coprime to n is n phi(n) / 2 (n &gt; 1)
 * - For any a, n coprime, a^(phi(n)) = 1 mod n
 * - Specifically, for any prime p, any number a, a^{p-1} = 1 mod p
 * Status: Tested
 */</FONT></I>
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">once</FONT>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> LIM = 5000000;
<B><FONT COLOR="#228B22">int</FONT></B> phi[LIM];

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">calculatePhi</FONT></B>() {
    rep(i,0,LIM) phi[i] = i&amp;1 ? i : i/2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 3; i &lt; LIM; i += 2) <B><FONT COLOR="#A020F0">if</FONT></B>(phi[i] == i)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i; j &lt; LIM; j += i) phi[j] -= phi[j] / i;
}</PRE>
<HR>
<A NAME="file27">
<H1>code/Partitions.cpp 27/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<I><FONT COLOR="#B22222">// Ways to write n as a sum of positive numbers.
</FONT></I><I><FONT COLOR="#B22222">// parition(4)=5 because 4 = 3 + 1 = 2 + 2 = 2 + 1 + 1 = 1 + 1 + 1 + 1
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">partition</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">if</FONT></B>(n==0) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    assert(n &gt; 0);
    vi dp = vi(n + 1);
    dp[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1, r = 1; i - (3 * j * j - j) / 2 &gt;= 0; j++, r *= -1) {
            dp[i] += dp[i - (3 * j * j - j) / 2] * r;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i - (3 * j * j + j) / 2 &gt;= 0) {
                dp[i] += dp[i - (3 * j * j + j) / 2] * r;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> dp[n];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// 0 1, 1 1, 2 2, 3 3, 4 5, 5 7, 6 11, 7 15, 8 22, 9 30, 10 42
</FONT></I>    <I><FONT COLOR="#B22222">// 11 56, 12 77, 13 101, 14 135, 15 176, 16 231, 17 297
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 17; ++i) {
        cout &lt;&lt; i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; partition(i) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file28">
<H1>code/BellmanFord.cc 28/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function runs the Bellman-Ford algorithm for single source
</FONT></I><I><FONT COLOR="#B22222">// shortest paths with negative edge weights.  The function returns
</FONT></I><I><FONT COLOR="#B22222">// false if a negative weight cycle is detected.  Otherwise, the
</FONT></I><I><FONT COLOR="#B22222">// function returns true and dist[i] is the length of the shortest
</FONT></I><I><FONT COLOR="#B22222">// path from start to i.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   start, w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  dist[i] = min weight path from start to i
</FONT></I><I><FONT COLOR="#B22222">//            prev[i] = previous node on the best path from the
</FONT></I><I><FONT COLOR="#B22222">//                      start node   
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">BellmanFord</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VT &amp;dist, VI &amp;prev, <B><FONT COLOR="#228B22">int</FONT></B> start) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    prev = VI(n, -1);
    dist = VT(n, 1000000000);
    dist[start] = 0;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (dist[j] &gt; dist[i] + w[i][j]) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (k == n - 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
                    dist[j] = dist[i] + w[i][j];
                    prev[j] = i;
                }
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
</PRE>
<HR>
<A NAME="file29">
<H1>code/TopologicalSort.cc 29/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function uses performs a non-recursive topological sort.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^2).  If you use adjacency lists (vector&lt;map&lt;int&gt; &gt;),
</FONT></I><I><FONT COLOR="#B22222">//               the running time is reduced to O(|E|).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   w[i][j] = 1 if i should come before j, 0 otherwise
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  a permutation of 0,...,n-1 (stored in a vector)
</FONT></I><I><FONT COLOR="#B22222">//            which represents an ordering of the nodes which
</FONT></I><I><FONT COLOR="#B22222">//            is consistent with w
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// If no ordering is possible, false is returned.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">TopologicalSort</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;order) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    VI parents(n);
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    order.clear();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[j][i]) parents[i]++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i] == 0) q.push(i);
    }

    <B><FONT COLOR="#A020F0">while</FONT></B> (q.size() &gt; 0) {
        <B><FONT COLOR="#228B22">int</FONT></B> i = q.front();
        q.pop();
        order.push_back(i);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j]) {
                parents[j]--;
                <B><FONT COLOR="#A020F0">if</FONT></B> (parents[j] == 0) q.push(j);
            }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> (order.size() == n);
}
</PRE>
<HR>
<A NAME="file30">
<H1>code/FastDijkstra.cc 30/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Implementation of Dijkstra's algorithm using adjacency lists
</FONT></I><I><FONT COLOR="#B22222">// and priority queue for efficiency.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|E| log |V|)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>

using namespace std;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 2000000000;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, s, t;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;N, &amp;s, &amp;t);
    vector&lt;vector&lt;PII&gt; &gt; edges(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> M;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; M; j++) {
            <B><FONT COLOR="#228B22">int</FONT></B> vertex, dist;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;vertex, &amp;dist);
            edges[i].push_back(make_pair(dist, vertex)); <I><FONT COLOR="#B22222">// note order of arguments here
</FONT></I>        }
    }

    <I><FONT COLOR="#B22222">// use priority queue in which top element has the &quot;smallest&quot; priority
</FONT></I>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; Q;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist(N, INF), dad(N, -1);
    Q.push(make_pair(0, s));
    dist[s] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
        PII p = Q.top();
        Q.pop();
        <B><FONT COLOR="#228B22">int</FONT></B> here = p.second;
        <B><FONT COLOR="#A020F0">if</FONT></B> (here == t) <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist[here] != p.first) <B><FONT COLOR="#A020F0">continue</FONT></B>;

        <B><FONT COLOR="#A020F0">for</FONT></B> (vector&lt;PII&gt;::iterator it = edges[here].begin(); it != edges[here].end(); it++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (dist[here] + it-&gt;first &lt; dist[it-&gt;second]) {
                dist[it-&gt;second] = dist[here] + it-&gt;first;
                dad[it-&gt;second] = here;
                Q.push(make_pair(dist[it-&gt;second], it-&gt;second));
            }
        }
    }

    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, dist[t]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist[t] &lt; INF)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = t; i != -1; i = dad[i])
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d%c&quot;</FONT></B>, i, (i == s ? <B><FONT COLOR="#BC8F8F">'\n'</FONT></B> : <B><FONT COLOR="#BC8F8F">' '</FONT></B>));
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/*
Sample input:
5 0 4
2 1 2 3 1
2 2 4 4 5
3 1 4 3 3 4 1
2 0 1 2 3
2 1 5 2 1

Expected:
5
4 2 3 0
*/</FONT></I></PRE>
<HR>
<A NAME="file31">
<H1>code/SCC.cc 31/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
vi val, comp, z, cont;
<B><FONT COLOR="#228B22">int</FONT></B> Time, ncomps;
<I><FONT COLOR="#B22222">// A function that will be called with the indicies of all elements
</FONT></I><I><FONT COLOR="#B22222">// in each component as the parameter once per component after running scc.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">f</FONT></B>(vi node_inds) {};
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j, vector&lt;vi&gt;&amp; g) {
    <B><FONT COLOR="#228B22">int</FONT></B> low = val[j] = ++Time, x; z.push_back(j);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : g[j]) <B><FONT COLOR="#A020F0">if</FONT></B> (comp[e] &lt; 0)
            low = min(low, val[e] ?: dfs(e,g));

    <B><FONT COLOR="#A020F0">if</FONT></B> (low == val[j]) {
        <B><FONT COLOR="#A020F0">do</FONT></B> {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } <B><FONT COLOR="#A020F0">while</FONT></B> (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> val[j] = low;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">scc</FONT></B>(vector&lt;vi&gt;&amp; g) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = g.size();
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) <B><FONT COLOR="#A020F0">if</FONT></B> (comp[i] &lt; 0) dfs(i, g);
}
</PRE>
<HR>
<A NAME="file32">
<H1>code/EulerianPath.cc 32/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Edge;
<B><FONT COLOR="#228B22">typedef</FONT></B> list&lt;Edge&gt;::iterator iter;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> next_vertex;
    iter reverse_edge;
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> next_vertex)
            : next_vertex(next_vertex) {}
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> max_vertices =;
<B><FONT COLOR="#228B22">int</FONT></B> num_vertices;
list &lt;Edge&gt; adj[max_vertices];        <I><FONT COLOR="#B22222">// adjacency list
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; path;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">find_path</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (adj[v].size() &gt; 0) {
        <B><FONT COLOR="#228B22">int</FONT></B> vn = adj[v].front().next_vertex;
        adj[vn].erase(adj[v].front().reverse_edge);
        adj[v].pop_front();
        find_path(vn);
    }
    path.push_back(v);
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">add_edge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    adj[a].push_front(Edge(b));
    iter ita = adj[a].begin();
    adj[b].push_front(Edge(a));
    iter itb = adj[b].begin();
    ita-&gt;reverse_edge = itb;
    itb-&gt;reverse_edge = ita;
}
</PRE>
<HR>
<A NAME="file33">
<H1>code/Prim.cc 33/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function runs Prim's algorithm for constructing minimum
</FONT></I><I><FONT COLOR="#B22222">// weight spanning trees.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^2)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//            NOTE: Make sure that w[i][j] is nonnegative and
</FONT></I><I><FONT COLOR="#B22222">//            symmetric.  Missing edges should be given -1
</FONT></I><I><FONT COLOR="#B22222">//            weight.
</FONT></I><I><FONT COLOR="#B22222">//            
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  edges = list of pair&lt;int,int&gt; in minimum spanning tree
</FONT></I><I><FONT COLOR="#B22222">//            return total weight of tree
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

T Prim(<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VPII &amp;edges) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    VI found(n);
    VI prev(n, -1);
    VT dist(n, 1000000000);
    <B><FONT COLOR="#228B22">int</FONT></B> here = 0;
    dist[here] = 0;

    <B><FONT COLOR="#A020F0">while</FONT></B> (here != -1) {
        found[here] = true;
        <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (!found[k]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (w[here][k] != -1 &amp;&amp; dist[k] &gt; w[here][k]) {
                    dist[k] = w[here][k];
                    prev[k] = here;
                }
                <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
            }
        here = best;
    }

    T tot_weight = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (prev[i] != -1) {
            edges.push_back(make_pair(prev[i], i));
            tot_weight += w[prev[i]][i];
        }
    <B><FONT COLOR="#A020F0">return</FONT></B> tot_weight;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> ww[5][5] = {
            {0,   400, 400, 300, 600},
            {400, 0,   3,   -1,  7},
            {400, 3,   0,   2,   0},
            {300, -1,  2,   0,   5},
            {600, 7,   0,   5,   0}
    };
    VVT w(5, VT(5));
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 5; j++)
            w[i][j] = ww[i][j];


    VPII edges;
    cout &lt;&lt; Prim(w, edges) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 305
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; edges.size(); i++)
        cout &lt;&lt; edges[i].first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; edges[i].second &lt;&lt; endl;
    <I><FONT COLOR="#B22222">//           2 1
</FONT></I>    <I><FONT COLOR="#B22222">//           3 2
</FONT></I>    <I><FONT COLOR="#B22222">//           0 3
</FONT></I>    <I><FONT COLOR="#B22222">//           2 4
</FONT></I>}
</PRE>
<HR>
<A NAME="file34">
<H1>code/AhoCorasick.cpp 34/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">foreach</FONT></B>(x, v) for (typeof (v).begin() x=(v).begin(); x !=(v).end(); ++x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">For</FONT></B>(i, a, b) for (int i=(a); i&lt;(b); ++i)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">D</FONT></B>(x) cout &lt;&lt; #x <B><FONT COLOR="#BC8F8F">&quot; is &quot;</FONT></B> &lt;&lt; x &lt;&lt; endl
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXS = 6 * 50 + 10; <I><FONT COLOR="#B22222">// Max number of states in the matching machine.
</FONT></I><I><FONT COLOR="#B22222">// Should be equal to the sum of the length of all keywords.
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXC = 26; <I><FONT COLOR="#B22222">// Number of characters in the alphabet.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> out[MAXS]; <I><FONT COLOR="#B22222">// Output for each state, as a bitwise mask.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> f[MAXS]; <I><FONT COLOR="#B22222">// Failure function
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> g[MAXS][MAXC]; <I><FONT COLOR="#B22222">// Goto function, or -1 if fail.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">buildMatchingMachine</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector &lt;string&gt; &amp;words, <B><FONT COLOR="#228B22">char</FONT></B> lowestChar = <B><FONT COLOR="#BC8F8F">'a'</FONT></B>,
                         <B><FONT COLOR="#228B22">char</FONT></B> highestChar = <B><FONT COLOR="#BC8F8F">'z'</FONT></B>) {
    memset(out, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> out);
    memset(f, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> f);
    memset(g, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> g);
    <B><FONT COLOR="#228B22">int</FONT></B> states = 1; <I><FONT COLOR="#B22222">// Initially, we just have the 0 state
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; words.size(); ++i) {
        <B><FONT COLOR="#228B22">const</FONT></B> string &amp;keyword = words[i];
        <B><FONT COLOR="#228B22">int</FONT></B> currentState = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; keyword.size(); ++j) {
            <B><FONT COLOR="#228B22">int</FONT></B> c = keyword[j] - lowestChar;
            <B><FONT COLOR="#A020F0">if</FONT></B> (g[currentState][c] == -1) { <I><FONT COLOR="#B22222">// Allocate a new node
</FONT></I>                g[currentState][c] = states++;
            }
            currentState = g[currentState][c];
        }
        out[currentState] |= (1 &lt;&lt; i); <I><FONT COLOR="#B22222">// There's a match of keywords[i] at node currentState.
</FONT></I>    }
    <I><FONT COLOR="#B22222">// State 0 should have an outgoing edge for all characters.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; MAXC; ++c) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (g[0][c] == -1) {
            g[0][c] = 0;
        }
    }

    <I><FONT COLOR="#B22222">// Now, let's build the failure function
</FONT></I>    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt;= highestChar - lowestChar; ++c) { <I><FONT COLOR="#B22222">// Iterate over every possible input
</FONT></I>        <I><FONT COLOR="#B22222">// All nodes s of depth 1 have f[s] = 0
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (g[0][c] != -1 and g[0][c] != 0) {
            f[g[0][c]] = 0;
            q.push(g[0][c]);
        }
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (q.size()) {
        <B><FONT COLOR="#228B22">int</FONT></B> state = q.front();
        q.pop();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt;= highestChar - lowestChar; ++c) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (g[state][c] != -1) {
                <B><FONT COLOR="#228B22">int</FONT></B> failure = f[state];
                <B><FONT COLOR="#A020F0">while</FONT></B> (g[failure][c] == -1) {
                    failure = f[failure];
                }
                failure = g[failure][c];
                f[g[state][c]] = failure;
                out[g[state][c]] |= out[failure]; <I><FONT COLOR="#B22222">// Merge out values
</FONT></I>                q.push(g[state][c]);
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> states;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">findNextState</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> currentState, <B><FONT COLOR="#228B22">char</FONT></B> nextInput, <B><FONT COLOR="#228B22">char</FONT></B> lowestChar = <B><FONT COLOR="#BC8F8F">'a'</FONT></B>) {
    <B><FONT COLOR="#228B22">int</FONT></B> answer = currentState;
    <B><FONT COLOR="#228B22">int</FONT></B> c = nextInput - lowestChar;
    <B><FONT COLOR="#A020F0">while</FONT></B> (g[answer][c] == -1)
        answer = f[answer];
    <B><FONT COLOR="#A020F0">return</FONT></B> g[answer][c];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    vector &lt;string&gt; keywords;
    keywords.push_back(<B><FONT COLOR="#BC8F8F">&quot;he&quot;</FONT></B>); keywords.push_back(<B><FONT COLOR="#BC8F8F">&quot;she&quot;</FONT></B>);
    keywords.push_back(<B><FONT COLOR="#BC8F8F">&quot;hers&quot;</FONT></B>); keywords.push_back(<B><FONT COLOR="#BC8F8F">&quot;his&quot;</FONT></B>);
    string text = <B><FONT COLOR="#BC8F8F">&quot;ahishers&quot;</FONT></B>;
    buildMatchingMachine(keywords, <B><FONT COLOR="#BC8F8F">'a'</FONT></B>, <B><FONT COLOR="#BC8F8F">'z'</FONT></B>);
    <B><FONT COLOR="#228B22">int</FONT></B> currentState = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; text.size(); ++i) {
        currentState = findNextState(currentState, text[i], <B><FONT COLOR="#BC8F8F">'a'</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B> (out[currentState] == 0)
            <B><FONT COLOR="#A020F0">continue</FONT></B>; <I><FONT COLOR="#B22222">// Nothing new, let's move on to the next character.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; keywords.size(); ++j) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (out[currentState] &amp; (1 &lt;&lt; j)) { <I><FONT COLOR="#B22222">// Matched keywords[j]
</FONT></I>                cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Keyword &quot;</FONT></B> &lt;&lt; keywords[j] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; appears from &quot;</FONT></B>
                     &lt;&lt; i - keywords[j].size() + 1 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; to &quot;</FONT></B> &lt;&lt; i &lt;&lt; endl;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</PRE>
<HR>
<A NAME="file35">
<H1>code/LongestIncreasingSubsequence.cc 35/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Given a list of numbers of length n, this routine extracts a
</FONT></I><I><FONT COLOR="#B22222">// longest increasing subsequence.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: a vector of integers
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: a vector containing the longest increasing subsequence
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>

VI <B><FONT COLOR="#0000FF">LongestIncreasingSubsequence</FONT></B>(VI v) {
    VPII best;
    VI dad(v.size(), -1);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>
        PII item = make_pair(v[i], 0);
        <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = lower_bound(best.begin(), best.end(), item);
        item.second = i;
#<B><FONT COLOR="#5F9EA0">else
</FONT></B>
        PII item = make_pair(v[i], i);
        <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = upper_bound(best.begin(), best.end(), item);
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>
        <B><FONT COLOR="#A020F0">if</FONT></B> (it == best.end()) {
            dad[i] = (best.size() == 0 ? -1 : best.back().second);
            best.push_back(item);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            dad[i] = it == best.begin() ? -1 : prev(it)-&gt;second;
            *it = item;
        }
    }

    VI ret;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = best.back().second; i &gt;= 0; i = dad[i])
        ret.push_back(v[i]);
    reverse(ret.begin(), ret.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
</PRE>
<HR>
<A NAME="file36">
<H1>code/LCS.cc 36/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Calculates the length of the longest common subsequence of two vectors.
Backtracks to find a single subsequence or all subsequences. Runs in
O(m*n) time except for finding all longest common subsequences, which
may be slow depending on how many there are.
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrack</FONT></B>(VVI &amp;dp, VT &amp;res, VT &amp;A, VT &amp;B, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!i || !j) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) {
        res.push_back(A[i - 1]);
        backtrack(dp, res, A, B, i - 1, j - 1);
    }
    <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &gt;= dp[i - 1][j]) backtrack(dp, res, A, B, i, j - 1);
        <B><FONT COLOR="#A020F0">else</FONT></B> backtrack(dp, res, A, B, i - 1, j);
    }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrackall</FONT></B>(VVI &amp;dp, set&lt;VT&gt; &amp;res, VT &amp;A, VT &amp;B, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!i || !j) {
        res.insert(VI());
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) {
        set&lt;VT&gt; tempres;
        backtrackall(dp, tempres, A, B, i - 1, j - 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (set&lt;VT&gt;::iterator it = tempres.begin(); it != tempres.end(); it++) {
            VT temp = *it;
            temp.push_back(A[i - 1]);
            res.insert(temp);
        }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &gt;= dp[i - 1][j]) backtrackall(dp, res, A, B, i, j - 1);
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &lt;= dp[i - 1][j]) backtrackall(dp, res, A, B, i - 1, j);
    }
}
VT <B><FONT COLOR="#0000FF">LCS</FONT></B>(VT &amp;A, VT &amp;B) {
    VVI dp;
    <B><FONT COLOR="#228B22">int</FONT></B> n = A.size(), m = B.size();
    dp.resize(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= n; i++) dp[i].resize(m + 1, 0);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            <B><FONT COLOR="#A020F0">else</FONT></B> dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }

    VT res;
    backtrack(dp, res, A, B, n, m);
    reverse(res.begin(), res.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
set&lt;VT&gt; LCSall(VT &amp;A, VT &amp;B) {
    VVI dp;
    <B><FONT COLOR="#228B22">int</FONT></B> n = A.size(), m = B.size();
    dp.resize(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= n; i++) dp[i].resize(m + 1, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            <B><FONT COLOR="#A020F0">else</FONT></B> dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    set&lt;VT&gt; res;
    backtrackall(dp, res, A, B, n, m);
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> a[] = {0, 5, 5, 2, 1, 4, 2, 3}, b[] = {5, 2, 4, 3, 2, 1, 2, 1, 3};
    VI A = VI(a, a + 8), B = VI(b, b + 9);
    VI C = LCS(A, B);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; C.size(); i++) cout &lt;&lt; C[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl &lt;&lt; endl;

    set&lt;VI&gt; D = LCSall(A, B);
    <B><FONT COLOR="#A020F0">for</FONT></B> (set&lt;VI&gt;::iterator it = D.begin(); it != D.end(); it++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (*it).size(); i++) cout &lt;&lt; (*it)[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file37">
<H1>code/KMP.cc 37/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Finds all occurrences of the pattern string p within the
text string t. Running time is O(n + m), where n and m
are the lengths of p and t, respecitvely.
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">buildPi</FONT></B>(string &amp;p, VI &amp;pi) {
    pi = VI(p.length());
    <B><FONT COLOR="#228B22">int</FONT></B> k = -2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.length(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (k &gt;= -1 &amp;&amp; p[k + 1] != p[i])
            k = (k == -1) ? -2 : pi[k];
        pi[i] = ++k;
    }
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">KMP</FONT></B>(string &amp;t, string &amp;p) {
    VI pi;
    buildPi(p, pi);
    <B><FONT COLOR="#228B22">int</FONT></B> k = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; t.length(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (k &gt;= -1 &amp;&amp; p[k + 1] != t[i])
            k = (k == -1) ? -2 : pi[k];
        k++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (k == p.length() - 1) {
            <I><FONT COLOR="#B22222">// p matches t[i-m+1, ..., i]
</FONT></I>            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;matched at index &quot;</FONT></B> &lt;&lt; i - k &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B>;
            cout &lt;&lt; t.substr(i - k, p.length()) &lt;&lt; endl;
            k = (k == -1) ? -2 : pi[k];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string a = <B><FONT COLOR="#BC8F8F">&quot;AABAACAADAABAABA&quot;</FONT></B>, b = <B><FONT COLOR="#BC8F8F">&quot;AABA&quot;</FONT></B>;
    KMP(a, b); <I><FONT COLOR="#B22222">// expected matches at: 0, 9, 12
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file38">
<H1>code/Zfunc.cpp 38/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: chilli
 * License: CC0
 * Description: z[x] computes the length of the longest common prefix of s[i:] and s, except z[0] = 0. (abacaba -&gt; 0010301)
 * Time: O(n)
 * Status: stress-tested
 */</FONT></I>
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">once</FONT>

vi <B><FONT COLOR="#0000FF">Z</FONT></B>(string S) {
    vi z(sz(S));
    <B><FONT COLOR="#228B22">int</FONT></B> l = -1, r = -1;
    rep(i,1,sz(S)) {
        z[i] = i &gt;= r ? 0 : min(r - i, z[i - l]);
        <B><FONT COLOR="#A020F0">while</FONT></B> (i + z[i] &lt; sz(S) &amp;&amp; S[i + z[i]] == S[z[i]])
            z[i]++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> z;
}</PRE>
<HR>
<A NAME="file39">
<H1>code/Manacher.cpp 39/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: User adamant on CodeForces
 * Source: http://codeforces.com/blog/entry/12143
 * Description: For each position in a string, computes p[0][i] = half length of
 *  longest even palindrome around pos i, p[1][i] = longest odd (half rounded down).
 * Time: O(N)
 * Status: Stress-tested
 */</FONT></I>
array&lt;vi, 2&gt; manacher(<B><FONT COLOR="#228B22">const</FONT></B> string&amp; s) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = sz(s);
    array&lt;vi,2&gt; p = {vi(n+1), vi(n)};
    rep(z,0,2) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=0,l=0,r=0; i &lt; n; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> t = r-i+!z;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i&lt;r) p[z][i] = min(t, p[z][l+t]);
            <B><FONT COLOR="#228B22">int</FONT></B> L = i-p[z][i], R = i+p[z][i]-!z;
            <B><FONT COLOR="#A020F0">while</FONT></B> (L&gt;=1 &amp;&amp; R+1&lt;n &amp;&amp; s[L-1] == s[R+1])
                p[z][i]++, L--, R++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (R&gt;r) l=L, r=R;
        }
    <B><FONT COLOR="#A020F0">return</FONT></B> p;
}</PRE>
<HR>
<A NAME="file40">
<H1>code/Primes.cc 40/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">EPS</FONT> 1e-7
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsPrime</FONT></B>(LL x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (x &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B> (x &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(x % 2) || !(x % 3)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    LL s = (LL) (sqrt((<B><FONT COLOR="#228B22">double</FONT></B>) (x)) + EPS);
    <B><FONT COLOR="#A020F0">for</FONT></B> (LL i = 5; i &lt;= s; i += 6) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!(x % i) || !(x % (i + 2))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// Factor every number up until n in O(n) time.
</FONT></I><I><FONT COLOR="#B22222">// minFact[i] = the minimum factor of i higher than 1. minFact[0] = minFact[1] = 0
</FONT></I><I><FONT COLOR="#B22222">// primes[i] = the ith prime.
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; factorAll(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; primes(0);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; minFact(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (minFact[i] == 0) {
            primes.push_back(i);
            minFact[i] = i;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; primes.size() &amp;&amp; primes[j] &lt;= minFact[i] &amp;&amp; i * primes[j] &lt;= n; ++j) {
            minFact[i * primes[j]] = primes[j];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> primes;
}
<I><FONT COLOR="#B22222">// Primes close to 1e9: 999'999'937, 1'000'000'007, 1'000'000'009
</FONT></I></PRE>
<HR>
<A NAME="file41">
<H1>code/BinarySearch.cpp 41/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][<A HREF="#file42">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This code is guaranteed to work in the min number of ops
</FONT></I><I><FONT COLOR="#B22222">// for any MAX that fits in an ll.
</FONT></I>ll MAX = 1LL &lt;&lt; 62;
<I><FONT COLOR="#B22222">// Binary search integers in the range [0, MAX] (or higher)
</FONT></I><I><FONT COLOR="#B22222">// for the last element satisfying condition.
</FONT></I>ll lo = 0
<B><FONT COLOR="#0000FF">for</FONT></B> (ll j = 1LL &lt;&lt; (ll) (log2(MAX)); j != 0; j &gt;&gt;= 1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (condition(lo + j)) {
        lo += j;
    }
}
<I><FONT COLOR="#B22222">// Binary search integers in the range (1, MAX] (or higher)
</FONT></I><I><FONT COLOR="#B22222">// for the first element satisfying condition.
</FONT></I>ll hi = 1LL &lt;&lt; (ll) (log2(MAX) + 1);
<B><FONT COLOR="#0000FF">for</FONT></B> (ll j = 1LL &lt;&lt; (ll) (log2(MAX)); j != 0; j &gt;&gt;= 1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (condition(hi - j)) {
        hi -= j;
    }
}
<I><FONT COLOR="#B22222">// Search list[lo:hi], targets occur at list[bisect_left:bisect_right]
</FONT></I><B><FONT COLOR="#0000FF">while</FONT></B> (lo &lt; hi) { <I><FONT COLOR="#B22222">// bisect_right
</FONT></I>    mid = lo + (hi - lo) / 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (target &lt; list[mid]) { hi = mid; }
    <B><FONT COLOR="#A020F0">else</FONT></B> { lo = mid + 1; }
} <B><FONT COLOR="#A020F0">return</FONT></B> lo;
<B><FONT COLOR="#0000FF">while</FONT></B> (lo &lt; hi) { <I><FONT COLOR="#B22222">// bisect_left
</FONT></I>    mid = lo + (hi - lo) / 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (list[mid] &lt; target) { lo = mid + 1; }
    <B><FONT COLOR="#A020F0">else</FONT></B> { hi = mid; }
} <B><FONT COLOR="#A020F0">return</FONT></B> lo;</PRE>
<HR>
<A NAME="file42">
<H1>code/LatLong.cc 42/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file41">prev</A>][<A HREF="#file43">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Converts from rectangular coordinates to latitude/longitude and vice
versa. Uses degrees (not radians).
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> ll {
    <B><FONT COLOR="#228B22">double</FONT></B> r, lat, lon;
};
<B><FONT COLOR="#228B22">struct</FONT></B> rect {
    <B><FONT COLOR="#228B22">double</FONT></B> x, y, z;
};
ll <B><FONT COLOR="#0000FF">convert</FONT></B>(rect &amp;P) {
    ll Q;
    Q.r = sqrt(P.x * P.x + P.y * P.y + P.z * P.z);
    Q.lat = 180 / M_PI * asin(P.z / Q.r);
    Q.lon = 180 / M_PI * acos(P.x / sqrt(P.x * P.x + P.y * P.y));

    <B><FONT COLOR="#A020F0">return</FONT></B> Q;
}
rect <B><FONT COLOR="#0000FF">convert</FONT></B>(ll &amp;Q) {
    rect P;
    P.x = Q.r * cos(Q.lon * M_PI / 180) * cos(Q.lat * M_PI / 180);
    P.y = Q.r * sin(Q.lon * M_PI / 180) * cos(Q.lat * M_PI / 180);
    P.z = Q.r * sin(Q.lat * M_PI / 180);

    <B><FONT COLOR="#A020F0">return</FONT></B> P;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    rect A;
    ll B;

    A.x = -1.0;
    A.y = 2.0;
    A.z = -3.0;

    B = convert(A);
    cout &lt;&lt; B.r &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; B.lat &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; B.lon &lt;&lt; endl;

    A = convert(B);
    cout &lt;&lt; A.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; A.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; A.z &lt;&lt; endl;
}
</PRE>
<HR>
<A NAME="file43">
<H1>code/HilbertCurve.cpp 43/43</H1>
[<A HREF="#top">top</A>][<A HREF="#file42">prev</A>][next]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Query {
    <B><FONT COLOR="#228B22">int</FONT></B> l, r, idx;
    int64_t ord;
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> calcOrder() {
        ord = hilbertOrder(l, r, 21, 0);
    }
};

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Query &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> Query &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.ord &lt; b.ord;
}
<I><FONT COLOR="#B22222">// contant time optimization to Mo's algorithm (~3x faster lol)
</FONT></I><I><FONT COLOR="#B22222">// https://codeforces.com/blog/entry/61203
</FONT></I><B><FONT COLOR="#228B22">inline</FONT></B> int64_t <B><FONT COLOR="#0000FF">hilbertOrder</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y, <B><FONT COLOR="#228B22">int</FONT></B> pow, <B><FONT COLOR="#228B22">int</FONT></B> rotate) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (pow == 0) {
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> hpow = 1 &lt;&lt; (pow - 1);
    <B><FONT COLOR="#228B22">int</FONT></B> seg = (x &lt; hpow) ? (
            (y &lt; hpow) ? 0 : 3
    ) : (
                      (y &lt; hpow) ? 1 : 2
              );
    seg = (seg + rotate) &amp; 3;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> rotateDelta[4] = {3, 0, 0, 1};
    <B><FONT COLOR="#228B22">int</FONT></B> nx = x &amp; (x ^ hpow), ny = y &amp; (y ^ hpow);
    <B><FONT COLOR="#228B22">int</FONT></B> nrot = (rotate + rotateDelta[seg]) &amp; 3;
    int64_t subSquareSize = int64_t(1) &lt;&lt; (2 * pow - 2);
    int64_t ans = seg * subSquareSize;
    int64_t add = hilbertOrder(nx, ny, pow - 1, nrot);
    ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);
    <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML>
